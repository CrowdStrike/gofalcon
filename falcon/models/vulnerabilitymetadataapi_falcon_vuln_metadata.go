// Code generated by go-swagger; DO NOT EDIT.

package models

// This file was generated by the swagger tool.
// Editing this file might prove futile when you re-run the swagger generate command

import (
	"context"
	"strconv"

	"github.com/go-openapi/errors"
	"github.com/go-openapi/strfmt"
	"github.com/go-openapi/swag"
	"github.com/go-openapi/validate"
)

// VulnerabilitymetadataapiFalconVulnMetadata vulnerabilitymetadataapi falcon vuln metadata
//
// swagger:model vulnerabilitymetadataapi.FalconVulnMetadata
type VulnerabilitymetadataapiFalconVulnMetadata struct {

	// actors
	// Required: true
	Actors []string `json:"actors"`

	// additional info
	// Required: true
	AdditionalInfo *string `json:"additional_info"`

	// cisa kev info
	// Required: true
	CisaKevInfo *VulnerabilitymetadataapiCISAKnownExploitedVulnerabilitiesInfo `json:"cisa_kev_info"`

	// created content id
	// Required: true
	CreatedContentID *string `json:"created_content_id"`

	// cs exploit
	// Required: true
	CsExploit *VulnerabilitymetadataapiCSExploit `json:"cs_exploit"`

	// exprt rating
	// Required: true
	ExprtRating *VulnerabilitymetadataapiExPRTRating `json:"exprt_rating"`

	// source
	// Required: true
	Source *string `json:"source"`

	// source type
	// Required: true
	SourceType *string `json:"source_type"`

	// spotlight published date
	// Required: true
	SpotlightPublishedDate *string `json:"spotlight_published_date"`

	// supported platforms
	// Required: true
	SupportedPlatforms []*VulnerabilitymetadataapiSupportedPlatform `json:"supported_platforms"`

	// types
	// Required: true
	Types []string `json:"types"`

	// updated content id
	// Required: true
	UpdatedContentID *string `json:"updated_content_id"`
}

// Validate validates this vulnerabilitymetadataapi falcon vuln metadata
func (m *VulnerabilitymetadataapiFalconVulnMetadata) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateActors(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateAdditionalInfo(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateCisaKevInfo(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateCreatedContentID(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateCsExploit(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateExprtRating(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateSource(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateSourceType(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateSpotlightPublishedDate(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateSupportedPlatforms(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateTypes(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateUpdatedContentID(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *VulnerabilitymetadataapiFalconVulnMetadata) validateActors(formats strfmt.Registry) error {

	if err := validate.Required("actors", "body", m.Actors); err != nil {
		return err
	}

	return nil
}

func (m *VulnerabilitymetadataapiFalconVulnMetadata) validateAdditionalInfo(formats strfmt.Registry) error {

	if err := validate.Required("additional_info", "body", m.AdditionalInfo); err != nil {
		return err
	}

	return nil
}

func (m *VulnerabilitymetadataapiFalconVulnMetadata) validateCisaKevInfo(formats strfmt.Registry) error {

	if err := validate.Required("cisa_kev_info", "body", m.CisaKevInfo); err != nil {
		return err
	}

	if m.CisaKevInfo != nil {
		if err := m.CisaKevInfo.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("cisa_kev_info")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("cisa_kev_info")
			}
			return err
		}
	}

	return nil
}

func (m *VulnerabilitymetadataapiFalconVulnMetadata) validateCreatedContentID(formats strfmt.Registry) error {

	if err := validate.Required("created_content_id", "body", m.CreatedContentID); err != nil {
		return err
	}

	return nil
}

func (m *VulnerabilitymetadataapiFalconVulnMetadata) validateCsExploit(formats strfmt.Registry) error {

	if err := validate.Required("cs_exploit", "body", m.CsExploit); err != nil {
		return err
	}

	if m.CsExploit != nil {
		if err := m.CsExploit.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("cs_exploit")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("cs_exploit")
			}
			return err
		}
	}

	return nil
}

func (m *VulnerabilitymetadataapiFalconVulnMetadata) validateExprtRating(formats strfmt.Registry) error {

	if err := validate.Required("exprt_rating", "body", m.ExprtRating); err != nil {
		return err
	}

	if m.ExprtRating != nil {
		if err := m.ExprtRating.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("exprt_rating")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("exprt_rating")
			}
			return err
		}
	}

	return nil
}

func (m *VulnerabilitymetadataapiFalconVulnMetadata) validateSource(formats strfmt.Registry) error {

	if err := validate.Required("source", "body", m.Source); err != nil {
		return err
	}

	return nil
}

func (m *VulnerabilitymetadataapiFalconVulnMetadata) validateSourceType(formats strfmt.Registry) error {

	if err := validate.Required("source_type", "body", m.SourceType); err != nil {
		return err
	}

	return nil
}

func (m *VulnerabilitymetadataapiFalconVulnMetadata) validateSpotlightPublishedDate(formats strfmt.Registry) error {

	if err := validate.Required("spotlight_published_date", "body", m.SpotlightPublishedDate); err != nil {
		return err
	}

	return nil
}

func (m *VulnerabilitymetadataapiFalconVulnMetadata) validateSupportedPlatforms(formats strfmt.Registry) error {

	if err := validate.Required("supported_platforms", "body", m.SupportedPlatforms); err != nil {
		return err
	}

	for i := 0; i < len(m.SupportedPlatforms); i++ {
		if swag.IsZero(m.SupportedPlatforms[i]) { // not required
			continue
		}

		if m.SupportedPlatforms[i] != nil {
			if err := m.SupportedPlatforms[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("supported_platforms" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("supported_platforms" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *VulnerabilitymetadataapiFalconVulnMetadata) validateTypes(formats strfmt.Registry) error {

	if err := validate.Required("types", "body", m.Types); err != nil {
		return err
	}

	return nil
}

func (m *VulnerabilitymetadataapiFalconVulnMetadata) validateUpdatedContentID(formats strfmt.Registry) error {

	if err := validate.Required("updated_content_id", "body", m.UpdatedContentID); err != nil {
		return err
	}

	return nil
}

// ContextValidate validate this vulnerabilitymetadataapi falcon vuln metadata based on the context it is used
func (m *VulnerabilitymetadataapiFalconVulnMetadata) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateCisaKevInfo(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateCsExploit(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateExprtRating(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateSupportedPlatforms(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *VulnerabilitymetadataapiFalconVulnMetadata) contextValidateCisaKevInfo(ctx context.Context, formats strfmt.Registry) error {

	if m.CisaKevInfo != nil {

		if err := m.CisaKevInfo.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("cisa_kev_info")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("cisa_kev_info")
			}
			return err
		}
	}

	return nil
}

func (m *VulnerabilitymetadataapiFalconVulnMetadata) contextValidateCsExploit(ctx context.Context, formats strfmt.Registry) error {

	if m.CsExploit != nil {

		if err := m.CsExploit.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("cs_exploit")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("cs_exploit")
			}
			return err
		}
	}

	return nil
}

func (m *VulnerabilitymetadataapiFalconVulnMetadata) contextValidateExprtRating(ctx context.Context, formats strfmt.Registry) error {

	if m.ExprtRating != nil {

		if err := m.ExprtRating.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("exprt_rating")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("exprt_rating")
			}
			return err
		}
	}

	return nil
}

func (m *VulnerabilitymetadataapiFalconVulnMetadata) contextValidateSupportedPlatforms(ctx context.Context, formats strfmt.Registry) error {

	for i := 0; i < len(m.SupportedPlatforms); i++ {

		if m.SupportedPlatforms[i] != nil {

			if swag.IsZero(m.SupportedPlatforms[i]) { // not required
				return nil
			}

			if err := m.SupportedPlatforms[i].ContextValidate(ctx, formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("supported_platforms" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("supported_platforms" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

// MarshalBinary interface implementation
func (m *VulnerabilitymetadataapiFalconVulnMetadata) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *VulnerabilitymetadataapiFalconVulnMetadata) UnmarshalBinary(b []byte) error {
	var res VulnerabilitymetadataapiFalconVulnMetadata
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}
