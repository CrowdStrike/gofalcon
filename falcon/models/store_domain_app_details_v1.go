// Code generated by go-swagger; DO NOT EDIT.

package models

// This file was generated by the swagger tool.
// Editing this file might prove futile when you re-run the swagger generate command

import (
	"context"
	"strconv"

	"github.com/go-openapi/errors"
	"github.com/go-openapi/strfmt"
	"github.com/go-openapi/swag"
	"github.com/go-openapi/validate"
)

// StoreDomainAppDetailsV1 store domain app details v1
//
// swagger:model store.domain.AppDetailsV1
type StoreDomainAppDetailsV1 struct {

	// activate with dependencies
	ActivateWithDependencies []string `json:"activate_with_dependencies"`

	// indicates whether this app is activated as a dependency for the given customer
	// Required: true
	ActivatedAsDependency *bool `json:"activated_as_dependency"`

	// name of sku, as defined in csam, that is associated with the app. Only returned when calling from admin ui.'
	AssignedSku string `json:"assigned_sku,omitempty"`

	// indicates whether the app is in beta mode. If so, it will only be visible to customers with the associated feature flag enabled.
	// Required: true
	Beta *bool `json:"beta"`

	// list of categories associated to the app (i.e. UEBA, Vuln Mgmt, Deception, etc.)
	Categories []string `json:"categories"`

	// Indicates whether the app can be configured.
	// Required: true
	Configurable *bool `json:"configurable"`

	// indicates days remaining in trial until expiration. It should only be visible after the trial has started.
	DaysRemaining int32 `json:"days_remaining,omitempty"`

	// link to demo video for educational purposes
	DemoURL string `json:"demo_url,omitempty"`

	// link to any partner provided documentation
	DocsURL string `json:"docs_url,omitempty"`

	// link to the partner provided Data Processing Agreement (DPA)
	DpaURL string `json:"dpa_url,omitempty"`

	// List of descriptive text for environment dependencies enabled for the app.
	EnvironmentRequirements []string `json:"environment_requirements"`

	// link to to the partner provided EULA
	EulaURL string `json:"eula_url,omitempty"`

	// to be rendered as bullet points in the UI. Specific call outs to key pieces of information about the app
	Features []string `json:"features"`

	// list of handlers associated to the app. Only returned when calling from admin ui.
	Handlers []string `json:"handlers"`

	// image for the app that is displayed in the marketplace listings/index page
	HeroImage string `json:"hero_image,omitempty"`

	// unique identifier for the app
	// Required: true
	ID *string `json:"id"`

	// Use for the get more info button. Link to any partner provided URL for details on app.
	InfoURL string `json:"info_url,omitempty"`

	// an arbitrary label assigned to the app. This is used presentation purposes to display apps under categories such as; featured, informational, falcon apps, etc.
	Labels []string `json:"labels"`

	// the latest available version for the customer to upgrade to.
	LatestVersion string `json:"latest_version,omitempty"`

	// link to login to partner product. This is only populated after activation has been completed.
	LoginURL string `json:"login_url,omitempty"`

	// logo for the app
	Logo string `json:"logo,omitempty"`

	// List of skus that the app requires which the user is not currently subscribed to.
	MissingSkus []string `json:"missing_skus"`

	// display name of the app
	Name string `json:"name,omitempty"`

	// list of pre-requisite Falcon modules that are optional for this app
	OptionalSkus []string `json:"optional_skus"`

	// detailed description and overview of the partner company and product
	// Required: true
	Overview *string `json:"overview"`

	// owner
	// Required: true
	Owner *StoreDomainOwnerDetailsV1 `json:"owner"`

	// pending trial expiration override days
	PendingTrialExpirationOverrideDays int32 `json:"pending_trial_expiration_override_days,omitempty"`

	// list of OS platforms the app supports
	Platforms []string `json:"platforms"`

	// a link or email address customers can contact for pricing inquiries
	Pricing string `json:"pricing,omitempty"`

	// link to the partner provided privacy agreement
	PrivacyURL string `json:"privacy_url,omitempty"`

	// list of pre-requisite Falcon modules that are required for this app to function
	RequiredSkus []string `json:"required_skus"`

	// provides additional links to resources related to the app
	ResourceLinks []*StoreDomainAppLinks `json:"resource_links"`

	// relative S3 path to screenshots of the app and associated alt text
	Screenshots []*StoreDomainScreenshotsV1 `json:"screenshots"`

	// OR operator set (true/false) to indicate that only one of skus are required
	// Required: true
	SkuRequirementOrOperatorSet *bool `json:"sku_requirement_or_operator_set"`

	// details to managed software package for this app if enabled.
	Software *StoreDomainManagedSoftwareResponse `json:"software,omitempty"`

	// state of the app for the given customer. Is empty this should default to AVAILABLE in the UI
	State string `json:"state,omitempty"`

	// high level summary used as a tag line
	// Required: true
	Summary *string `json:"summary"`

	// list of supported clouds. This is used to filter the app listing to available apps per cloud.
	SupportedClouds []string `json:"supported_clouds"`

	// indicates whether the app can be activated or not. Informational apps cannot be.
	// Required: true
	TrialReady *bool `json:"trial_ready"`

	// indicates whether the latest version is greater than the current version meaning a version upgrade is available.
	// Required: true
	UpgradeAvailable *bool `json:"upgrade_available"`

	// a description that speaks specifically to the integration use cases between the partner product and Falcon
	Usecases string `json:"usecases,omitempty"`

	// the version of the app the version which the customer has activated.
	Version *StoreDomainVersionDetailsV1 `json:"version,omitempty"`
}

// Validate validates this store domain app details v1
func (m *StoreDomainAppDetailsV1) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateActivatedAsDependency(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateBeta(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateConfigurable(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateID(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateOverview(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateOwner(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateResourceLinks(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateScreenshots(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateSkuRequirementOrOperatorSet(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateSoftware(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateSummary(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateTrialReady(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateUpgradeAvailable(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateVersion(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *StoreDomainAppDetailsV1) validateActivatedAsDependency(formats strfmt.Registry) error {

	if err := validate.Required("activated_as_dependency", "body", m.ActivatedAsDependency); err != nil {
		return err
	}

	return nil
}

func (m *StoreDomainAppDetailsV1) validateBeta(formats strfmt.Registry) error {

	if err := validate.Required("beta", "body", m.Beta); err != nil {
		return err
	}

	return nil
}

func (m *StoreDomainAppDetailsV1) validateConfigurable(formats strfmt.Registry) error {

	if err := validate.Required("configurable", "body", m.Configurable); err != nil {
		return err
	}

	return nil
}

func (m *StoreDomainAppDetailsV1) validateID(formats strfmt.Registry) error {

	if err := validate.Required("id", "body", m.ID); err != nil {
		return err
	}

	return nil
}

func (m *StoreDomainAppDetailsV1) validateOverview(formats strfmt.Registry) error {

	if err := validate.Required("overview", "body", m.Overview); err != nil {
		return err
	}

	return nil
}

func (m *StoreDomainAppDetailsV1) validateOwner(formats strfmt.Registry) error {

	if err := validate.Required("owner", "body", m.Owner); err != nil {
		return err
	}

	if m.Owner != nil {
		if err := m.Owner.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("owner")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("owner")
			}
			return err
		}
	}

	return nil
}

func (m *StoreDomainAppDetailsV1) validateResourceLinks(formats strfmt.Registry) error {
	if swag.IsZero(m.ResourceLinks) { // not required
		return nil
	}

	for i := 0; i < len(m.ResourceLinks); i++ {
		if swag.IsZero(m.ResourceLinks[i]) { // not required
			continue
		}

		if m.ResourceLinks[i] != nil {
			if err := m.ResourceLinks[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("resource_links" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("resource_links" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *StoreDomainAppDetailsV1) validateScreenshots(formats strfmt.Registry) error {
	if swag.IsZero(m.Screenshots) { // not required
		return nil
	}

	for i := 0; i < len(m.Screenshots); i++ {
		if swag.IsZero(m.Screenshots[i]) { // not required
			continue
		}

		if m.Screenshots[i] != nil {
			if err := m.Screenshots[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("screenshots" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("screenshots" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *StoreDomainAppDetailsV1) validateSkuRequirementOrOperatorSet(formats strfmt.Registry) error {

	if err := validate.Required("sku_requirement_or_operator_set", "body", m.SkuRequirementOrOperatorSet); err != nil {
		return err
	}

	return nil
}

func (m *StoreDomainAppDetailsV1) validateSoftware(formats strfmt.Registry) error {
	if swag.IsZero(m.Software) { // not required
		return nil
	}

	if m.Software != nil {
		if err := m.Software.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("software")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("software")
			}
			return err
		}
	}

	return nil
}

func (m *StoreDomainAppDetailsV1) validateSummary(formats strfmt.Registry) error {

	if err := validate.Required("summary", "body", m.Summary); err != nil {
		return err
	}

	return nil
}

func (m *StoreDomainAppDetailsV1) validateTrialReady(formats strfmt.Registry) error {

	if err := validate.Required("trial_ready", "body", m.TrialReady); err != nil {
		return err
	}

	return nil
}

func (m *StoreDomainAppDetailsV1) validateUpgradeAvailable(formats strfmt.Registry) error {

	if err := validate.Required("upgrade_available", "body", m.UpgradeAvailable); err != nil {
		return err
	}

	return nil
}

func (m *StoreDomainAppDetailsV1) validateVersion(formats strfmt.Registry) error {
	if swag.IsZero(m.Version) { // not required
		return nil
	}

	if m.Version != nil {
		if err := m.Version.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("version")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("version")
			}
			return err
		}
	}

	return nil
}

// ContextValidate validate this store domain app details v1 based on the context it is used
func (m *StoreDomainAppDetailsV1) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateOwner(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateResourceLinks(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateScreenshots(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateSoftware(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateVersion(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *StoreDomainAppDetailsV1) contextValidateOwner(ctx context.Context, formats strfmt.Registry) error {

	if m.Owner != nil {
		if err := m.Owner.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("owner")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("owner")
			}
			return err
		}
	}

	return nil
}

func (m *StoreDomainAppDetailsV1) contextValidateResourceLinks(ctx context.Context, formats strfmt.Registry) error {

	for i := 0; i < len(m.ResourceLinks); i++ {

		if m.ResourceLinks[i] != nil {
			if err := m.ResourceLinks[i].ContextValidate(ctx, formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("resource_links" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("resource_links" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *StoreDomainAppDetailsV1) contextValidateScreenshots(ctx context.Context, formats strfmt.Registry) error {

	for i := 0; i < len(m.Screenshots); i++ {

		if m.Screenshots[i] != nil {
			if err := m.Screenshots[i].ContextValidate(ctx, formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("screenshots" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("screenshots" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *StoreDomainAppDetailsV1) contextValidateSoftware(ctx context.Context, formats strfmt.Registry) error {

	if m.Software != nil {
		if err := m.Software.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("software")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("software")
			}
			return err
		}
	}

	return nil
}

func (m *StoreDomainAppDetailsV1) contextValidateVersion(ctx context.Context, formats strfmt.Registry) error {

	if m.Version != nil {
		if err := m.Version.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("version")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("version")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (m *StoreDomainAppDetailsV1) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *StoreDomainAppDetailsV1) UnmarshalBinary(b []byte) error {
	var res StoreDomainAppDetailsV1
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}
