// Code generated by go-swagger; DO NOT EDIT.

package models

// This file was generated by the swagger tool.
// Editing this file might prove futile when you re-run the swagger generate command

import (
	"context"
	"strconv"

	"github.com/go-openapi/errors"
	"github.com/go-openapi/strfmt"
	"github.com/go-openapi/swag"
	"github.com/go-openapi/validate"
)

// ModelsRuleProperties models rule properties
//
// swagger:model models.RuleProperties
type ModelsRuleProperties struct {

	// cvss attack complexity
	// Required: true
	CvssAttackComplexity *string `json:"cvssAttackComplexity"`

	// cvss attack vector
	// Required: true
	CvssAttackVector *string `json:"cvssAttackVector"`

	// cvss availability impact
	// Required: true
	CvssAvailabilityImpact *string `json:"cvssAvailabilityImpact"`

	// cvss base score
	// Required: true
	CvssBaseScore *float64 `json:"cvssBaseScore"`

	// cvss confidentiality impact
	// Required: true
	CvssConfidentialityImpact *string `json:"cvssConfidentialityImpact"`

	// cvss exploitability score
	// Required: true
	CvssExploitabilityScore *float64 `json:"cvssExploitabilityScore"`

	// cvss impact score
	// Required: true
	CvssImpactScore *float64 `json:"cvssImpactScore"`

	// cvss integrity impact
	// Required: true
	CvssIntegrityImpact *string `json:"cvssIntegrityImpact"`

	// cvss privileges required
	// Required: true
	CvssPrivilegesRequired *string `json:"cvssPrivilegesRequired"`

	// cvss scope
	// Required: true
	CvssScope *string `json:"cvssScope"`

	// cvss source
	// Required: true
	CvssSource *string `json:"cvssSource"`

	// cvss user interaction
	// Required: true
	CvssUserInteraction *string `json:"cvssUserInteraction"`

	// cvss vector
	// Required: true
	CvssVector *string `json:"cvssVector"`

	// description
	// Required: true
	Description *string `json:"description"`

	// exploit date recorded timestamp
	// Required: true
	ExploitDateRecordedTimestamp *int64 `json:"exploitDateRecordedTimestamp"`

	// exploit sources
	// Required: true
	ExploitSources []*IngestionCVEExploitSource `json:"exploitSources"`

	// exploit status
	// Required: true
	ExploitStatus *string `json:"exploitStatus"`

	// exploit updated timestamp
	// Required: true
	ExploitUpdatedTimestamp *int64 `json:"exploitUpdatedTimestamp"`

	// exprt rating
	// Required: true
	ExprtRating *string `json:"exprtRating"`

	// exprt rating date recorded timestamp
	// Required: true
	ExprtRatingDateRecordedTimestamp *int64 `json:"exprtRatingDateRecordedTimestamp"`

	// exprt rating highest
	// Required: true
	ExprtRatingHighest *string `json:"exprtRatingHighest"`

	// exprt rating highest recorded timestamp
	// Required: true
	ExprtRatingHighestRecordedTimestamp *int64 `json:"exprtRatingHighestRecordedTimestamp"`

	// first seen timestamp
	// Required: true
	FirstSeenTimestamp *int64 `json:"firstSeenTimestamp"`

	// references
	// Required: true
	References []*IngestionReference `json:"references"`

	// remediation count
	// Required: true
	RemediationCount *int32 `json:"remediationCount"`

	// remediation sources
	// Required: true
	RemediationSources []string `json:"remediationSources"`

	// remediations
	// Required: true
	Remediations []string `json:"remediations"`

	// runtime
	// Required: true
	Runtime *string `json:"runtime"`

	// scanner version
	// Required: true
	ScannerVersion *string `json:"scannerVersion"`

	// severity
	// Required: true
	Severity *string `json:"severity"`

	// top exprt rating factors
	// Required: true
	TopExprtRatingFactors []*IngestionExPRTRatingFactors `json:"topExprtRatingFactors"`
}

// Validate validates this models rule properties
func (m *ModelsRuleProperties) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateCvssAttackComplexity(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateCvssAttackVector(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateCvssAvailabilityImpact(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateCvssBaseScore(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateCvssConfidentialityImpact(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateCvssExploitabilityScore(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateCvssImpactScore(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateCvssIntegrityImpact(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateCvssPrivilegesRequired(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateCvssScope(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateCvssSource(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateCvssUserInteraction(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateCvssVector(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateDescription(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateExploitDateRecordedTimestamp(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateExploitSources(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateExploitStatus(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateExploitUpdatedTimestamp(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateExprtRating(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateExprtRatingDateRecordedTimestamp(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateExprtRatingHighest(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateExprtRatingHighestRecordedTimestamp(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateFirstSeenTimestamp(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateReferences(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateRemediationCount(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateRemediationSources(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateRemediations(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateRuntime(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateScannerVersion(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateSeverity(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateTopExprtRatingFactors(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *ModelsRuleProperties) validateCvssAttackComplexity(formats strfmt.Registry) error {

	if err := validate.Required("cvssAttackComplexity", "body", m.CvssAttackComplexity); err != nil {
		return err
	}

	return nil
}

func (m *ModelsRuleProperties) validateCvssAttackVector(formats strfmt.Registry) error {

	if err := validate.Required("cvssAttackVector", "body", m.CvssAttackVector); err != nil {
		return err
	}

	return nil
}

func (m *ModelsRuleProperties) validateCvssAvailabilityImpact(formats strfmt.Registry) error {

	if err := validate.Required("cvssAvailabilityImpact", "body", m.CvssAvailabilityImpact); err != nil {
		return err
	}

	return nil
}

func (m *ModelsRuleProperties) validateCvssBaseScore(formats strfmt.Registry) error {

	if err := validate.Required("cvssBaseScore", "body", m.CvssBaseScore); err != nil {
		return err
	}

	return nil
}

func (m *ModelsRuleProperties) validateCvssConfidentialityImpact(formats strfmt.Registry) error {

	if err := validate.Required("cvssConfidentialityImpact", "body", m.CvssConfidentialityImpact); err != nil {
		return err
	}

	return nil
}

func (m *ModelsRuleProperties) validateCvssExploitabilityScore(formats strfmt.Registry) error {

	if err := validate.Required("cvssExploitabilityScore", "body", m.CvssExploitabilityScore); err != nil {
		return err
	}

	return nil
}

func (m *ModelsRuleProperties) validateCvssImpactScore(formats strfmt.Registry) error {

	if err := validate.Required("cvssImpactScore", "body", m.CvssImpactScore); err != nil {
		return err
	}

	return nil
}

func (m *ModelsRuleProperties) validateCvssIntegrityImpact(formats strfmt.Registry) error {

	if err := validate.Required("cvssIntegrityImpact", "body", m.CvssIntegrityImpact); err != nil {
		return err
	}

	return nil
}

func (m *ModelsRuleProperties) validateCvssPrivilegesRequired(formats strfmt.Registry) error {

	if err := validate.Required("cvssPrivilegesRequired", "body", m.CvssPrivilegesRequired); err != nil {
		return err
	}

	return nil
}

func (m *ModelsRuleProperties) validateCvssScope(formats strfmt.Registry) error {

	if err := validate.Required("cvssScope", "body", m.CvssScope); err != nil {
		return err
	}

	return nil
}

func (m *ModelsRuleProperties) validateCvssSource(formats strfmt.Registry) error {

	if err := validate.Required("cvssSource", "body", m.CvssSource); err != nil {
		return err
	}

	return nil
}

func (m *ModelsRuleProperties) validateCvssUserInteraction(formats strfmt.Registry) error {

	if err := validate.Required("cvssUserInteraction", "body", m.CvssUserInteraction); err != nil {
		return err
	}

	return nil
}

func (m *ModelsRuleProperties) validateCvssVector(formats strfmt.Registry) error {

	if err := validate.Required("cvssVector", "body", m.CvssVector); err != nil {
		return err
	}

	return nil
}

func (m *ModelsRuleProperties) validateDescription(formats strfmt.Registry) error {

	if err := validate.Required("description", "body", m.Description); err != nil {
		return err
	}

	return nil
}

func (m *ModelsRuleProperties) validateExploitDateRecordedTimestamp(formats strfmt.Registry) error {

	if err := validate.Required("exploitDateRecordedTimestamp", "body", m.ExploitDateRecordedTimestamp); err != nil {
		return err
	}

	return nil
}

func (m *ModelsRuleProperties) validateExploitSources(formats strfmt.Registry) error {

	if err := validate.Required("exploitSources", "body", m.ExploitSources); err != nil {
		return err
	}

	for i := 0; i < len(m.ExploitSources); i++ {
		if swag.IsZero(m.ExploitSources[i]) { // not required
			continue
		}

		if m.ExploitSources[i] != nil {
			if err := m.ExploitSources[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("exploitSources" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("exploitSources" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *ModelsRuleProperties) validateExploitStatus(formats strfmt.Registry) error {

	if err := validate.Required("exploitStatus", "body", m.ExploitStatus); err != nil {
		return err
	}

	return nil
}

func (m *ModelsRuleProperties) validateExploitUpdatedTimestamp(formats strfmt.Registry) error {

	if err := validate.Required("exploitUpdatedTimestamp", "body", m.ExploitUpdatedTimestamp); err != nil {
		return err
	}

	return nil
}

func (m *ModelsRuleProperties) validateExprtRating(formats strfmt.Registry) error {

	if err := validate.Required("exprtRating", "body", m.ExprtRating); err != nil {
		return err
	}

	return nil
}

func (m *ModelsRuleProperties) validateExprtRatingDateRecordedTimestamp(formats strfmt.Registry) error {

	if err := validate.Required("exprtRatingDateRecordedTimestamp", "body", m.ExprtRatingDateRecordedTimestamp); err != nil {
		return err
	}

	return nil
}

func (m *ModelsRuleProperties) validateExprtRatingHighest(formats strfmt.Registry) error {

	if err := validate.Required("exprtRatingHighest", "body", m.ExprtRatingHighest); err != nil {
		return err
	}

	return nil
}

func (m *ModelsRuleProperties) validateExprtRatingHighestRecordedTimestamp(formats strfmt.Registry) error {

	if err := validate.Required("exprtRatingHighestRecordedTimestamp", "body", m.ExprtRatingHighestRecordedTimestamp); err != nil {
		return err
	}

	return nil
}

func (m *ModelsRuleProperties) validateFirstSeenTimestamp(formats strfmt.Registry) error {

	if err := validate.Required("firstSeenTimestamp", "body", m.FirstSeenTimestamp); err != nil {
		return err
	}

	return nil
}

func (m *ModelsRuleProperties) validateReferences(formats strfmt.Registry) error {

	if err := validate.Required("references", "body", m.References); err != nil {
		return err
	}

	for i := 0; i < len(m.References); i++ {
		if swag.IsZero(m.References[i]) { // not required
			continue
		}

		if m.References[i] != nil {
			if err := m.References[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("references" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("references" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *ModelsRuleProperties) validateRemediationCount(formats strfmt.Registry) error {

	if err := validate.Required("remediationCount", "body", m.RemediationCount); err != nil {
		return err
	}

	return nil
}

func (m *ModelsRuleProperties) validateRemediationSources(formats strfmt.Registry) error {

	if err := validate.Required("remediationSources", "body", m.RemediationSources); err != nil {
		return err
	}

	return nil
}

func (m *ModelsRuleProperties) validateRemediations(formats strfmt.Registry) error {

	if err := validate.Required("remediations", "body", m.Remediations); err != nil {
		return err
	}

	return nil
}

func (m *ModelsRuleProperties) validateRuntime(formats strfmt.Registry) error {

	if err := validate.Required("runtime", "body", m.Runtime); err != nil {
		return err
	}

	return nil
}

func (m *ModelsRuleProperties) validateScannerVersion(formats strfmt.Registry) error {

	if err := validate.Required("scannerVersion", "body", m.ScannerVersion); err != nil {
		return err
	}

	return nil
}

func (m *ModelsRuleProperties) validateSeverity(formats strfmt.Registry) error {

	if err := validate.Required("severity", "body", m.Severity); err != nil {
		return err
	}

	return nil
}

func (m *ModelsRuleProperties) validateTopExprtRatingFactors(formats strfmt.Registry) error {

	if err := validate.Required("topExprtRatingFactors", "body", m.TopExprtRatingFactors); err != nil {
		return err
	}

	for i := 0; i < len(m.TopExprtRatingFactors); i++ {
		if swag.IsZero(m.TopExprtRatingFactors[i]) { // not required
			continue
		}

		if m.TopExprtRatingFactors[i] != nil {
			if err := m.TopExprtRatingFactors[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("topExprtRatingFactors" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("topExprtRatingFactors" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

// ContextValidate validate this models rule properties based on the context it is used
func (m *ModelsRuleProperties) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateExploitSources(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateReferences(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateTopExprtRatingFactors(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *ModelsRuleProperties) contextValidateExploitSources(ctx context.Context, formats strfmt.Registry) error {

	for i := 0; i < len(m.ExploitSources); i++ {

		if m.ExploitSources[i] != nil {

			if swag.IsZero(m.ExploitSources[i]) { // not required
				return nil
			}

			if err := m.ExploitSources[i].ContextValidate(ctx, formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("exploitSources" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("exploitSources" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *ModelsRuleProperties) contextValidateReferences(ctx context.Context, formats strfmt.Registry) error {

	for i := 0; i < len(m.References); i++ {

		if m.References[i] != nil {

			if swag.IsZero(m.References[i]) { // not required
				return nil
			}

			if err := m.References[i].ContextValidate(ctx, formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("references" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("references" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *ModelsRuleProperties) contextValidateTopExprtRatingFactors(ctx context.Context, formats strfmt.Registry) error {

	for i := 0; i < len(m.TopExprtRatingFactors); i++ {

		if m.TopExprtRatingFactors[i] != nil {

			if swag.IsZero(m.TopExprtRatingFactors[i]) { // not required
				return nil
			}

			if err := m.TopExprtRatingFactors[i].ContextValidate(ctx, formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("topExprtRatingFactors" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("topExprtRatingFactors" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

// MarshalBinary interface implementation
func (m *ModelsRuleProperties) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *ModelsRuleProperties) UnmarshalBinary(b []byte) error {
	var res ModelsRuleProperties
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}
