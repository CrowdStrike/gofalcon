// Code generated by go-swagger; DO NOT EDIT.

package models

// This file was generated by the swagger tool.
// Editing this file might prove futile when you re-run the swagger generate command

import (
	"context"
	"strconv"

	"github.com/go-openapi/errors"
	"github.com/go-openapi/strfmt"
	"github.com/go-openapi/swag"
	"github.com/go-openapi/validate"
)

// ApimodelsRule apimodels rule
//
// swagger:model apimodels.Rule
type ApimodelsRule struct {

	// alert info
	// Required: true
	AlertInfo *string `json:"alert_info"`

	// attack types
	AttackTypes []string `json:"attack_types"`

	// auto remediable
	// Required: true
	AutoRemediable *bool `json:"auto_remediable"`

	// category
	Category string `json:"category,omitempty"`

	// cid
	// Required: true
	Cid *string `json:"cid"`

	// controls
	// Required: true
	Controls []*ApimodelsControl `json:"controls"`

	// created at
	// Required: true
	// Format: date-time
	CreatedAt *strfmt.DateTime `json:"created_at"`

	// created by
	// Required: true
	CreatedBy *string `json:"created_by"`

	// custom configuration
	CustomConfiguration interface{} `json:"custom_configuration,omitempty"`

	// deleted at
	// Format: date-time
	DeletedAt strfmt.DateTime `json:"deleted_at,omitempty"`

	// deleted by
	DeletedBy string `json:"deleted_by,omitempty"`

	// deprecated
	Deprecated bool `json:"deprecated,omitempty"`

	// description
	// Required: true
	Description *string `json:"description"`

	// domain
	// Required: true
	Domain *string `json:"domain"`

	// logic
	Logic string `json:"logic,omitempty"`

	// logic format
	LogicFormat string `json:"logic_format,omitempty"`

	// mitre tactics id
	// Required: true
	MitreTacticsID *string `json:"mitre_tactics_id"`

	// mitre tactics name
	// Required: true
	MitreTacticsName *string `json:"mitre_tactics_name"`

	// mitre tactics url
	// Required: true
	MitreTacticsURL *string `json:"mitre_tactics_url"`

	// mitre techniques id
	// Required: true
	MitreTechniquesID *string `json:"mitre_techniques_id"`

	// mitre techniques name
	// Required: true
	MitreTechniquesName *string `json:"mitre_techniques_name"`

	// mitre techniques url
	// Required: true
	MitreTechniquesURL *string `json:"mitre_techniques_url"`

	// mutable
	Mutable string `json:"mutable,omitempty"`

	// name
	// Required: true
	Name *string `json:"name"`

	// origin
	// Required: true
	Origin *string `json:"origin"`

	// overrides
	// Required: true
	Overrides []*ApimodelsRuleOverride `json:"overrides"`

	// parent rule pk
	ParentRulePk int32 `json:"parent_rule__pk,omitempty"`

	// parent rule short code
	ParentRuleShortCode int32 `json:"parent_rule_short_code,omitempty"`

	// parent rule short uuid
	ParentRuleShortUUID string `json:"parent_rule_short_uuid,omitempty"`

	// platform
	Platform string `json:"platform,omitempty"`

	// provider
	// Required: true
	Provider *string `json:"provider"`

	// remediation
	// Required: true
	Remediation *string `json:"remediation"`

	// remediation url
	RemediationURL string `json:"remediation_url,omitempty"`

	// resource metadata
	ResourceMetadata string `json:"resource_metadata,omitempty"`

	// resource types
	// Required: true
	ResourceTypes []*ApimodelsResourceType `json:"resource_types"`

	// revision
	Revision int32 `json:"revision,omitempty"`

	// rule logic list
	// Required: true
	RuleLogicList []*ApimodelsRuleLogic `json:"rule_logic_list"`

	// severity
	// Required: true
	Severity *int64 `json:"severity"`

	// short code
	// Required: true
	ShortCode *int32 `json:"short_code"`

	// subdomain
	// Required: true
	Subdomain *string `json:"subdomain"`

	// update reason
	UpdateReason string `json:"update_reason,omitempty"`

	// updated at
	// Format: date-time
	UpdatedAt strfmt.DateTime `json:"updated_at,omitempty"`

	// updated by
	UpdatedBy string `json:"updated_by,omitempty"`

	// uuid
	// Required: true
	UUID *string `json:"uuid"`

	// visible
	Visible bool `json:"visible,omitempty"`
}

// Validate validates this apimodels rule
func (m *ApimodelsRule) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateAlertInfo(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateAutoRemediable(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateCid(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateControls(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateCreatedAt(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateCreatedBy(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateDeletedAt(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateDescription(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateDomain(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateMitreTacticsID(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateMitreTacticsName(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateMitreTacticsURL(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateMitreTechniquesID(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateMitreTechniquesName(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateMitreTechniquesURL(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateName(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateOrigin(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateOverrides(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateProvider(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateRemediation(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateResourceTypes(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateRuleLogicList(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateSeverity(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateShortCode(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateSubdomain(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateUpdatedAt(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateUUID(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *ApimodelsRule) validateAlertInfo(formats strfmt.Registry) error {

	if err := validate.Required("alert_info", "body", m.AlertInfo); err != nil {
		return err
	}

	return nil
}

func (m *ApimodelsRule) validateAutoRemediable(formats strfmt.Registry) error {

	if err := validate.Required("auto_remediable", "body", m.AutoRemediable); err != nil {
		return err
	}

	return nil
}

func (m *ApimodelsRule) validateCid(formats strfmt.Registry) error {

	if err := validate.Required("cid", "body", m.Cid); err != nil {
		return err
	}

	return nil
}

func (m *ApimodelsRule) validateControls(formats strfmt.Registry) error {

	if err := validate.Required("controls", "body", m.Controls); err != nil {
		return err
	}

	for i := 0; i < len(m.Controls); i++ {
		if swag.IsZero(m.Controls[i]) { // not required
			continue
		}

		if m.Controls[i] != nil {
			if err := m.Controls[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("controls" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("controls" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *ApimodelsRule) validateCreatedAt(formats strfmt.Registry) error {

	if err := validate.Required("created_at", "body", m.CreatedAt); err != nil {
		return err
	}

	if err := validate.FormatOf("created_at", "body", "date-time", m.CreatedAt.String(), formats); err != nil {
		return err
	}

	return nil
}

func (m *ApimodelsRule) validateCreatedBy(formats strfmt.Registry) error {

	if err := validate.Required("created_by", "body", m.CreatedBy); err != nil {
		return err
	}

	return nil
}

func (m *ApimodelsRule) validateDeletedAt(formats strfmt.Registry) error {
	if swag.IsZero(m.DeletedAt) { // not required
		return nil
	}

	if err := validate.FormatOf("deleted_at", "body", "date-time", m.DeletedAt.String(), formats); err != nil {
		return err
	}

	return nil
}

func (m *ApimodelsRule) validateDescription(formats strfmt.Registry) error {

	if err := validate.Required("description", "body", m.Description); err != nil {
		return err
	}

	return nil
}

func (m *ApimodelsRule) validateDomain(formats strfmt.Registry) error {

	if err := validate.Required("domain", "body", m.Domain); err != nil {
		return err
	}

	return nil
}

func (m *ApimodelsRule) validateMitreTacticsID(formats strfmt.Registry) error {

	if err := validate.Required("mitre_tactics_id", "body", m.MitreTacticsID); err != nil {
		return err
	}

	return nil
}

func (m *ApimodelsRule) validateMitreTacticsName(formats strfmt.Registry) error {

	if err := validate.Required("mitre_tactics_name", "body", m.MitreTacticsName); err != nil {
		return err
	}

	return nil
}

func (m *ApimodelsRule) validateMitreTacticsURL(formats strfmt.Registry) error {

	if err := validate.Required("mitre_tactics_url", "body", m.MitreTacticsURL); err != nil {
		return err
	}

	return nil
}

func (m *ApimodelsRule) validateMitreTechniquesID(formats strfmt.Registry) error {

	if err := validate.Required("mitre_techniques_id", "body", m.MitreTechniquesID); err != nil {
		return err
	}

	return nil
}

func (m *ApimodelsRule) validateMitreTechniquesName(formats strfmt.Registry) error {

	if err := validate.Required("mitre_techniques_name", "body", m.MitreTechniquesName); err != nil {
		return err
	}

	return nil
}

func (m *ApimodelsRule) validateMitreTechniquesURL(formats strfmt.Registry) error {

	if err := validate.Required("mitre_techniques_url", "body", m.MitreTechniquesURL); err != nil {
		return err
	}

	return nil
}

func (m *ApimodelsRule) validateName(formats strfmt.Registry) error {

	if err := validate.Required("name", "body", m.Name); err != nil {
		return err
	}

	return nil
}

func (m *ApimodelsRule) validateOrigin(formats strfmt.Registry) error {

	if err := validate.Required("origin", "body", m.Origin); err != nil {
		return err
	}

	return nil
}

func (m *ApimodelsRule) validateOverrides(formats strfmt.Registry) error {

	if err := validate.Required("overrides", "body", m.Overrides); err != nil {
		return err
	}

	for i := 0; i < len(m.Overrides); i++ {
		if swag.IsZero(m.Overrides[i]) { // not required
			continue
		}

		if m.Overrides[i] != nil {
			if err := m.Overrides[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("overrides" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("overrides" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *ApimodelsRule) validateProvider(formats strfmt.Registry) error {

	if err := validate.Required("provider", "body", m.Provider); err != nil {
		return err
	}

	return nil
}

func (m *ApimodelsRule) validateRemediation(formats strfmt.Registry) error {

	if err := validate.Required("remediation", "body", m.Remediation); err != nil {
		return err
	}

	return nil
}

func (m *ApimodelsRule) validateResourceTypes(formats strfmt.Registry) error {

	if err := validate.Required("resource_types", "body", m.ResourceTypes); err != nil {
		return err
	}

	for i := 0; i < len(m.ResourceTypes); i++ {
		if swag.IsZero(m.ResourceTypes[i]) { // not required
			continue
		}

		if m.ResourceTypes[i] != nil {
			if err := m.ResourceTypes[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("resource_types" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("resource_types" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *ApimodelsRule) validateRuleLogicList(formats strfmt.Registry) error {

	if err := validate.Required("rule_logic_list", "body", m.RuleLogicList); err != nil {
		return err
	}

	for i := 0; i < len(m.RuleLogicList); i++ {
		if swag.IsZero(m.RuleLogicList[i]) { // not required
			continue
		}

		if m.RuleLogicList[i] != nil {
			if err := m.RuleLogicList[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("rule_logic_list" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("rule_logic_list" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *ApimodelsRule) validateSeverity(formats strfmt.Registry) error {

	if err := validate.Required("severity", "body", m.Severity); err != nil {
		return err
	}

	return nil
}

func (m *ApimodelsRule) validateShortCode(formats strfmt.Registry) error {

	if err := validate.Required("short_code", "body", m.ShortCode); err != nil {
		return err
	}

	return nil
}

func (m *ApimodelsRule) validateSubdomain(formats strfmt.Registry) error {

	if err := validate.Required("subdomain", "body", m.Subdomain); err != nil {
		return err
	}

	return nil
}

func (m *ApimodelsRule) validateUpdatedAt(formats strfmt.Registry) error {
	if swag.IsZero(m.UpdatedAt) { // not required
		return nil
	}

	if err := validate.FormatOf("updated_at", "body", "date-time", m.UpdatedAt.String(), formats); err != nil {
		return err
	}

	return nil
}

func (m *ApimodelsRule) validateUUID(formats strfmt.Registry) error {

	if err := validate.Required("uuid", "body", m.UUID); err != nil {
		return err
	}

	return nil
}

// ContextValidate validate this apimodels rule based on the context it is used
func (m *ApimodelsRule) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateControls(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateOverrides(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateResourceTypes(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateRuleLogicList(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *ApimodelsRule) contextValidateControls(ctx context.Context, formats strfmt.Registry) error {

	for i := 0; i < len(m.Controls); i++ {

		if m.Controls[i] != nil {

			if swag.IsZero(m.Controls[i]) { // not required
				return nil
			}

			if err := m.Controls[i].ContextValidate(ctx, formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("controls" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("controls" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *ApimodelsRule) contextValidateOverrides(ctx context.Context, formats strfmt.Registry) error {

	for i := 0; i < len(m.Overrides); i++ {

		if m.Overrides[i] != nil {

			if swag.IsZero(m.Overrides[i]) { // not required
				return nil
			}

			if err := m.Overrides[i].ContextValidate(ctx, formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("overrides" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("overrides" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *ApimodelsRule) contextValidateResourceTypes(ctx context.Context, formats strfmt.Registry) error {

	for i := 0; i < len(m.ResourceTypes); i++ {

		if m.ResourceTypes[i] != nil {

			if swag.IsZero(m.ResourceTypes[i]) { // not required
				return nil
			}

			if err := m.ResourceTypes[i].ContextValidate(ctx, formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("resource_types" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("resource_types" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *ApimodelsRule) contextValidateRuleLogicList(ctx context.Context, formats strfmt.Registry) error {

	for i := 0; i < len(m.RuleLogicList); i++ {

		if m.RuleLogicList[i] != nil {

			if swag.IsZero(m.RuleLogicList[i]) { // not required
				return nil
			}

			if err := m.RuleLogicList[i].ContextValidate(ctx, formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("rule_logic_list" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("rule_logic_list" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

// MarshalBinary interface implementation
func (m *ApimodelsRule) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *ApimodelsRule) UnmarshalBinary(b []byte) error {
	var res ApimodelsRule
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}
