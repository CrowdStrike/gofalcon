// Code generated by go-swagger; DO NOT EDIT.

package models

// This file was generated by the swagger tool.
// Editing this file might prove futile when you re-run the swagger generate command

import (
	"context"
	"strconv"

	"github.com/go-openapi/errors"
	"github.com/go-openapi/strfmt"
	"github.com/go-openapi/swag"
	"github.com/go-openapi/validate"
)

// DomainActorDocument JSON definition of an Actor, also known as Adversary
//
// swagger:model domain.ActorDocument
type DomainActorDocument struct {

	// Boolean field marking if actor is active
	// Required: true
	Active *bool `json:"active"`

	// Actor type, one of: targeted, ecrime
	ActorType string `json:"actor_type,omitempty"`

	// actor's capabilities, some examples: RAT,Ransomware,Spearphishing,Downloader,Backdoor,InformationStealer,exploit,CredentialHarvesting,dropper,DenialOfService,Loader,Phishing
	// Required: true
	Capabilities []DomainEntity `json:"capabilities"`

	// Capability of actor's activity, one of: Below Average, Average, Above average
	Capability DomainEntity `json:"capability,omitempty"`

	// Actor's document creation date when it was added to the Falcon portal in unix timestamp format
	// Required: true
	CreatedDate *int64 `json:"created_date"`

	// Actor's text description, partially containing structured data from other fields
	Description string `json:"description,omitempty"`

	// description length
	DescriptionLength int64 `json:"description_length,omitempty"`

	// develops threats
	DevelopsThreats []*DomainThreatEntity `json:"develops_threats"`

	// develops threats count
	DevelopsThreatsCount int64 `json:"develops_threats_count,omitempty"`

	// Multi-field property describing eCrime actor's kill chain
	EcrimeKillChain *DomainECrimeKillChain `json:"ecrime_kill_chain,omitempty"`

	// Field used to filter user's access to actor documents
	Entitlements []DomainEntity `json:"entitlements"`

	// Actor's first activity observed date in unix timestamp format
	// Required: true
	FirstActivityDate *int64 `json:"first_activity_date"`

	// Deprecated, unused field
	Group DomainEntity `json:"group,omitempty"`

	// has subgroup
	HasSubgroup []*DomainActorEntity `json:"has_subgroup"`

	// has subgroup actors count
	HasSubgroupActorsCount int64 `json:"has_subgroup_actors_count,omitempty"`

	// has successor
	HasSuccessor []*DomainActorEntity `json:"has_successor"`

	// has successor actors count
	HasSuccessorActorsCount int64 `json:"has_successor_actors_count,omitempty"`

	// Numerical ID for the Actor
	// Required: true
	ID *int64 `json:"id"`

	// Image used in UI
	Image *DomainImage `json:"image,omitempty"`

	// in reports
	InReports []*DomainActorNewsDocument `json:"in_reports"`

	// in reports count
	InReportsCount int64 `json:"in_reports_count,omitempty"`

	// is subgroup of
	IsSubgroupOf []*DomainActorEntity `json:"is_subgroup_of"`

	// is subgroup of actors count
	IsSubgroupOfActorsCount int64 `json:"is_subgroup_of_actors_count,omitempty"`

	// is successor of
	IsSuccessorOf []*DomainActorEntity `json:"is_successor_of"`

	// is successor of actors count
	IsSuccessorOfActorsCount int64 `json:"is_successor_of_actors_count,omitempty"`

	// is supported by
	IsSupportedBy []*DomainActorEntity `json:"is_supported_by"`

	// is supported by actors count
	IsSupportedByActorsCount int64 `json:"is_supported_by_actors_count,omitempty"`

	// Multi-field property describing actor's kill chain
	KillChain *DomainKillChain `json:"kill_chain,omitempty"`

	// Alternative names and community identifiers of an actor
	// Required: true
	KnownAs *string `json:"known_as"`

	// Actor's last (most recent) activity observed date in unix timestamp format
	// Required: true
	LastActivityDate *int64 `json:"last_activity_date"`

	// Actor's document last modified date in unix timestamp format
	// Required: true
	LastModifiedDate *int64 `json:"last_modified_date"`

	// Actor's activity motivation, one of: State-Sponsored, Criminal, Hacktivism
	// Required: true
	Motivations []DomainEntity `json:"motivations"`

	// Actor's name, composed of 2 words
	Name string `json:"name,omitempty"`

	// internal field
	// Required: true
	NotifyUsers *bool `json:"notify_users"`

	// Actor's activity objectives, one of: IntelligenceGathering, FinancialGain, IntellectualPropertyTheft, defacement, Destruction, DenialOfService
	// Required: true
	Objectives []DomainEntity `json:"objectives"`

	// represents origin of actor's activity and/or members, some examples: China,Russian Federation,Eastern Europe,Iran,East Asia, South Asia
	// Required: true
	Origins []DomainEntity `json:"origins"`

	// Recent CrowdStrike's finished intelligence alerting date in unix timestamp format
	RecentAlerting int64 `json:"recent_alerting,omitempty"`

	// Deprecated, unused field
	Region DomainEntity `json:"region,omitempty"`

	// Rich text version of the description field
	RichTextDescription string `json:"rich_text_description,omitempty"`

	// sells threats
	SellsThreats []*DomainThreatEntity `json:"sells_threats"`

	// sells threats count
	SellsThreatsCount int64 `json:"sells_threats_count,omitempty"`

	// Short version of the description field
	// Required: true
	ShortDescription *string `json:"short_description"`

	// Name in url friendly format, lowercased and spaces replaced with dash
	Slug string `json:"slug,omitempty"`

	// Status of an actor, one of: Active, Inactive, Retired
	// Required: true
	Status *string `json:"status"`

	// supports
	Supports []*DomainActorEntity `json:"supports"`

	// supports actors count
	SupportsActorsCount int64 `json:"supports_actors_count,omitempty"`

	// Target countries of actor's activity and attacks, slug value is a 2 characters code for the country value, some examples: United States,United Kingdom,Germany,India,Japan,France,Australia,Canada,China
	// Required: true
	TargetCountries []DomainEntity `json:"target_countries"`

	// Target economical industries of actor's activity and attacks. List of available values: Government, Financial Services, Technology, Telecommunications, Healthcare, Energy, Academic, Media, Aerospace, NGO, Manufacturing, Industrials and Engineering, Retail, Hospitality, Consulting and Professional Services, Opportunistic, Aviation, Defense, Transportation, Oil and Gas, Legal, Pharmaceutical, Logistics, Military, Automotive, Food and Beverage, Consumer Goods, Real Estate, Insurance, Agriculture, Chemicals, Utilities, Maritime, Extractive, Travel, Dissident, Cryptocurrency, Entertainment, National Government, Law Enforcement, Think Tanks, Local Government, Sports Organizations, Computer Gaming, Biomedical, Nonprofit, Financial Management & Hedge Funds, Political Parties, Architectural and Engineering, Emergency Services, Social Media, International Government, Nuclear, Research Entities, Vocational and Higher-Level Education, eCommerce
	// Required: true
	TargetIndustries []DomainEntity `json:"target_industries"`

	// Target geographic regions of actor's activity and attacks. List of available values: North America, Western Europe, Southeast Asia, Middle East, Eastern Europe, South Asia, South America, Oceania, East Asia, Central Africa, Northern Europe, Southern Europe, North Africa, Southern Africa, Central America, Central Asia, East Africa, West Africa, Caribbean
	// Required: true
	TargetRegions []DomainEntity `json:"target_regions"`

	// Thumbnail image used in UI
	Thumbnail *DomainImage `json:"thumbnail,omitempty"`

	// URL at which actor profile can be accessed
	URL string `json:"url,omitempty"`

	// uses indicators count
	UsesIndicatorsCount int64 `json:"uses_indicators_count,omitempty"`

	// uses mitre attacks count
	UsesMitreAttacksCount int64 `json:"uses_mitre_attacks_count,omitempty"`

	// uses mitre tactics count
	UsesMitreTacticsCount int64 `json:"uses_mitre_tactics_count,omitempty"`

	// uses mitre techniques count
	UsesMitreTechniquesCount int64 `json:"uses_mitre_techniques_count,omitempty"`

	// uses threats
	UsesThreats []*DomainThreatEntity `json:"uses_threats"`

	// uses threats count
	UsesThreatsCount int64 `json:"uses_threats_count,omitempty"`

	// Comma separated values of vulnerabilities by CVE codes that are exploited by actor
	UsesVulnerabilities []string `json:"uses_vulnerabilities"`

	// vulnerabilities count
	VulnerabilitiesCount int64 `json:"vulnerabilities_count,omitempty"`
}

// Validate validates this domain actor document
func (m *DomainActorDocument) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateActive(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateCapabilities(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateCreatedDate(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateDevelopsThreats(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateEcrimeKillChain(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateFirstActivityDate(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateHasSubgroup(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateHasSuccessor(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateID(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateImage(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateInReports(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateIsSubgroupOf(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateIsSuccessorOf(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateIsSupportedBy(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateKillChain(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateKnownAs(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateLastActivityDate(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateLastModifiedDate(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateMotivations(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateNotifyUsers(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateObjectives(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateOrigins(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateSellsThreats(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateShortDescription(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateStatus(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateSupports(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateTargetCountries(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateTargetIndustries(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateTargetRegions(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateThumbnail(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateUsesThreats(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *DomainActorDocument) validateActive(formats strfmt.Registry) error {

	if err := validate.Required("active", "body", m.Active); err != nil {
		return err
	}

	return nil
}

func (m *DomainActorDocument) validateCapabilities(formats strfmt.Registry) error {

	if err := validate.Required("capabilities", "body", m.Capabilities); err != nil {
		return err
	}

	return nil
}

func (m *DomainActorDocument) validateCreatedDate(formats strfmt.Registry) error {

	if err := validate.Required("created_date", "body", m.CreatedDate); err != nil {
		return err
	}

	return nil
}

func (m *DomainActorDocument) validateDevelopsThreats(formats strfmt.Registry) error {
	if swag.IsZero(m.DevelopsThreats) { // not required
		return nil
	}

	for i := 0; i < len(m.DevelopsThreats); i++ {
		if swag.IsZero(m.DevelopsThreats[i]) { // not required
			continue
		}

		if m.DevelopsThreats[i] != nil {
			if err := m.DevelopsThreats[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("develops_threats" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("develops_threats" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *DomainActorDocument) validateEcrimeKillChain(formats strfmt.Registry) error {
	if swag.IsZero(m.EcrimeKillChain) { // not required
		return nil
	}

	if m.EcrimeKillChain != nil {
		if err := m.EcrimeKillChain.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("ecrime_kill_chain")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("ecrime_kill_chain")
			}
			return err
		}
	}

	return nil
}

func (m *DomainActorDocument) validateFirstActivityDate(formats strfmt.Registry) error {

	if err := validate.Required("first_activity_date", "body", m.FirstActivityDate); err != nil {
		return err
	}

	return nil
}

func (m *DomainActorDocument) validateHasSubgroup(formats strfmt.Registry) error {
	if swag.IsZero(m.HasSubgroup) { // not required
		return nil
	}

	for i := 0; i < len(m.HasSubgroup); i++ {
		if swag.IsZero(m.HasSubgroup[i]) { // not required
			continue
		}

		if m.HasSubgroup[i] != nil {
			if err := m.HasSubgroup[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("has_subgroup" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("has_subgroup" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *DomainActorDocument) validateHasSuccessor(formats strfmt.Registry) error {
	if swag.IsZero(m.HasSuccessor) { // not required
		return nil
	}

	for i := 0; i < len(m.HasSuccessor); i++ {
		if swag.IsZero(m.HasSuccessor[i]) { // not required
			continue
		}

		if m.HasSuccessor[i] != nil {
			if err := m.HasSuccessor[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("has_successor" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("has_successor" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *DomainActorDocument) validateID(formats strfmt.Registry) error {

	if err := validate.Required("id", "body", m.ID); err != nil {
		return err
	}

	return nil
}

func (m *DomainActorDocument) validateImage(formats strfmt.Registry) error {
	if swag.IsZero(m.Image) { // not required
		return nil
	}

	if m.Image != nil {
		if err := m.Image.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("image")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("image")
			}
			return err
		}
	}

	return nil
}

func (m *DomainActorDocument) validateInReports(formats strfmt.Registry) error {
	if swag.IsZero(m.InReports) { // not required
		return nil
	}

	for i := 0; i < len(m.InReports); i++ {
		if swag.IsZero(m.InReports[i]) { // not required
			continue
		}

		if m.InReports[i] != nil {
			if err := m.InReports[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("in_reports" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("in_reports" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *DomainActorDocument) validateIsSubgroupOf(formats strfmt.Registry) error {
	if swag.IsZero(m.IsSubgroupOf) { // not required
		return nil
	}

	for i := 0; i < len(m.IsSubgroupOf); i++ {
		if swag.IsZero(m.IsSubgroupOf[i]) { // not required
			continue
		}

		if m.IsSubgroupOf[i] != nil {
			if err := m.IsSubgroupOf[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("is_subgroup_of" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("is_subgroup_of" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *DomainActorDocument) validateIsSuccessorOf(formats strfmt.Registry) error {
	if swag.IsZero(m.IsSuccessorOf) { // not required
		return nil
	}

	for i := 0; i < len(m.IsSuccessorOf); i++ {
		if swag.IsZero(m.IsSuccessorOf[i]) { // not required
			continue
		}

		if m.IsSuccessorOf[i] != nil {
			if err := m.IsSuccessorOf[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("is_successor_of" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("is_successor_of" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *DomainActorDocument) validateIsSupportedBy(formats strfmt.Registry) error {
	if swag.IsZero(m.IsSupportedBy) { // not required
		return nil
	}

	for i := 0; i < len(m.IsSupportedBy); i++ {
		if swag.IsZero(m.IsSupportedBy[i]) { // not required
			continue
		}

		if m.IsSupportedBy[i] != nil {
			if err := m.IsSupportedBy[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("is_supported_by" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("is_supported_by" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *DomainActorDocument) validateKillChain(formats strfmt.Registry) error {
	if swag.IsZero(m.KillChain) { // not required
		return nil
	}

	if m.KillChain != nil {
		if err := m.KillChain.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("kill_chain")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("kill_chain")
			}
			return err
		}
	}

	return nil
}

func (m *DomainActorDocument) validateKnownAs(formats strfmt.Registry) error {

	if err := validate.Required("known_as", "body", m.KnownAs); err != nil {
		return err
	}

	return nil
}

func (m *DomainActorDocument) validateLastActivityDate(formats strfmt.Registry) error {

	if err := validate.Required("last_activity_date", "body", m.LastActivityDate); err != nil {
		return err
	}

	return nil
}

func (m *DomainActorDocument) validateLastModifiedDate(formats strfmt.Registry) error {

	if err := validate.Required("last_modified_date", "body", m.LastModifiedDate); err != nil {
		return err
	}

	return nil
}

func (m *DomainActorDocument) validateMotivations(formats strfmt.Registry) error {

	if err := validate.Required("motivations", "body", m.Motivations); err != nil {
		return err
	}

	return nil
}

func (m *DomainActorDocument) validateNotifyUsers(formats strfmt.Registry) error {

	if err := validate.Required("notify_users", "body", m.NotifyUsers); err != nil {
		return err
	}

	return nil
}

func (m *DomainActorDocument) validateObjectives(formats strfmt.Registry) error {

	if err := validate.Required("objectives", "body", m.Objectives); err != nil {
		return err
	}

	return nil
}

func (m *DomainActorDocument) validateOrigins(formats strfmt.Registry) error {

	if err := validate.Required("origins", "body", m.Origins); err != nil {
		return err
	}

	return nil
}

func (m *DomainActorDocument) validateSellsThreats(formats strfmt.Registry) error {
	if swag.IsZero(m.SellsThreats) { // not required
		return nil
	}

	for i := 0; i < len(m.SellsThreats); i++ {
		if swag.IsZero(m.SellsThreats[i]) { // not required
			continue
		}

		if m.SellsThreats[i] != nil {
			if err := m.SellsThreats[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("sells_threats" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("sells_threats" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *DomainActorDocument) validateShortDescription(formats strfmt.Registry) error {

	if err := validate.Required("short_description", "body", m.ShortDescription); err != nil {
		return err
	}

	return nil
}

func (m *DomainActorDocument) validateStatus(formats strfmt.Registry) error {

	if err := validate.Required("status", "body", m.Status); err != nil {
		return err
	}

	return nil
}

func (m *DomainActorDocument) validateSupports(formats strfmt.Registry) error {
	if swag.IsZero(m.Supports) { // not required
		return nil
	}

	for i := 0; i < len(m.Supports); i++ {
		if swag.IsZero(m.Supports[i]) { // not required
			continue
		}

		if m.Supports[i] != nil {
			if err := m.Supports[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("supports" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("supports" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *DomainActorDocument) validateTargetCountries(formats strfmt.Registry) error {

	if err := validate.Required("target_countries", "body", m.TargetCountries); err != nil {
		return err
	}

	return nil
}

func (m *DomainActorDocument) validateTargetIndustries(formats strfmt.Registry) error {

	if err := validate.Required("target_industries", "body", m.TargetIndustries); err != nil {
		return err
	}

	return nil
}

func (m *DomainActorDocument) validateTargetRegions(formats strfmt.Registry) error {

	if err := validate.Required("target_regions", "body", m.TargetRegions); err != nil {
		return err
	}

	return nil
}

func (m *DomainActorDocument) validateThumbnail(formats strfmt.Registry) error {
	if swag.IsZero(m.Thumbnail) { // not required
		return nil
	}

	if m.Thumbnail != nil {
		if err := m.Thumbnail.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("thumbnail")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("thumbnail")
			}
			return err
		}
	}

	return nil
}

func (m *DomainActorDocument) validateUsesThreats(formats strfmt.Registry) error {
	if swag.IsZero(m.UsesThreats) { // not required
		return nil
	}

	for i := 0; i < len(m.UsesThreats); i++ {
		if swag.IsZero(m.UsesThreats[i]) { // not required
			continue
		}

		if m.UsesThreats[i] != nil {
			if err := m.UsesThreats[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("uses_threats" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("uses_threats" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

// ContextValidate validate this domain actor document based on the context it is used
func (m *DomainActorDocument) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateDevelopsThreats(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateEcrimeKillChain(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateHasSubgroup(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateHasSuccessor(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateImage(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateInReports(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateIsSubgroupOf(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateIsSuccessorOf(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateIsSupportedBy(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateKillChain(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateSellsThreats(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateSupports(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateThumbnail(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateUsesThreats(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *DomainActorDocument) contextValidateDevelopsThreats(ctx context.Context, formats strfmt.Registry) error {

	for i := 0; i < len(m.DevelopsThreats); i++ {

		if m.DevelopsThreats[i] != nil {

			if swag.IsZero(m.DevelopsThreats[i]) { // not required
				return nil
			}

			if err := m.DevelopsThreats[i].ContextValidate(ctx, formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("develops_threats" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("develops_threats" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *DomainActorDocument) contextValidateEcrimeKillChain(ctx context.Context, formats strfmt.Registry) error {

	if m.EcrimeKillChain != nil {

		if swag.IsZero(m.EcrimeKillChain) { // not required
			return nil
		}

		if err := m.EcrimeKillChain.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("ecrime_kill_chain")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("ecrime_kill_chain")
			}
			return err
		}
	}

	return nil
}

func (m *DomainActorDocument) contextValidateHasSubgroup(ctx context.Context, formats strfmt.Registry) error {

	for i := 0; i < len(m.HasSubgroup); i++ {

		if m.HasSubgroup[i] != nil {

			if swag.IsZero(m.HasSubgroup[i]) { // not required
				return nil
			}

			if err := m.HasSubgroup[i].ContextValidate(ctx, formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("has_subgroup" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("has_subgroup" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *DomainActorDocument) contextValidateHasSuccessor(ctx context.Context, formats strfmt.Registry) error {

	for i := 0; i < len(m.HasSuccessor); i++ {

		if m.HasSuccessor[i] != nil {

			if swag.IsZero(m.HasSuccessor[i]) { // not required
				return nil
			}

			if err := m.HasSuccessor[i].ContextValidate(ctx, formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("has_successor" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("has_successor" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *DomainActorDocument) contextValidateImage(ctx context.Context, formats strfmt.Registry) error {

	if m.Image != nil {

		if swag.IsZero(m.Image) { // not required
			return nil
		}

		if err := m.Image.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("image")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("image")
			}
			return err
		}
	}

	return nil
}

func (m *DomainActorDocument) contextValidateInReports(ctx context.Context, formats strfmt.Registry) error {

	for i := 0; i < len(m.InReports); i++ {

		if m.InReports[i] != nil {

			if swag.IsZero(m.InReports[i]) { // not required
				return nil
			}

			if err := m.InReports[i].ContextValidate(ctx, formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("in_reports" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("in_reports" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *DomainActorDocument) contextValidateIsSubgroupOf(ctx context.Context, formats strfmt.Registry) error {

	for i := 0; i < len(m.IsSubgroupOf); i++ {

		if m.IsSubgroupOf[i] != nil {

			if swag.IsZero(m.IsSubgroupOf[i]) { // not required
				return nil
			}

			if err := m.IsSubgroupOf[i].ContextValidate(ctx, formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("is_subgroup_of" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("is_subgroup_of" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *DomainActorDocument) contextValidateIsSuccessorOf(ctx context.Context, formats strfmt.Registry) error {

	for i := 0; i < len(m.IsSuccessorOf); i++ {

		if m.IsSuccessorOf[i] != nil {

			if swag.IsZero(m.IsSuccessorOf[i]) { // not required
				return nil
			}

			if err := m.IsSuccessorOf[i].ContextValidate(ctx, formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("is_successor_of" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("is_successor_of" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *DomainActorDocument) contextValidateIsSupportedBy(ctx context.Context, formats strfmt.Registry) error {

	for i := 0; i < len(m.IsSupportedBy); i++ {

		if m.IsSupportedBy[i] != nil {

			if swag.IsZero(m.IsSupportedBy[i]) { // not required
				return nil
			}

			if err := m.IsSupportedBy[i].ContextValidate(ctx, formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("is_supported_by" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("is_supported_by" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *DomainActorDocument) contextValidateKillChain(ctx context.Context, formats strfmt.Registry) error {

	if m.KillChain != nil {

		if swag.IsZero(m.KillChain) { // not required
			return nil
		}

		if err := m.KillChain.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("kill_chain")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("kill_chain")
			}
			return err
		}
	}

	return nil
}

func (m *DomainActorDocument) contextValidateSellsThreats(ctx context.Context, formats strfmt.Registry) error {

	for i := 0; i < len(m.SellsThreats); i++ {

		if m.SellsThreats[i] != nil {

			if swag.IsZero(m.SellsThreats[i]) { // not required
				return nil
			}

			if err := m.SellsThreats[i].ContextValidate(ctx, formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("sells_threats" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("sells_threats" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *DomainActorDocument) contextValidateSupports(ctx context.Context, formats strfmt.Registry) error {

	for i := 0; i < len(m.Supports); i++ {

		if m.Supports[i] != nil {

			if swag.IsZero(m.Supports[i]) { // not required
				return nil
			}

			if err := m.Supports[i].ContextValidate(ctx, formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("supports" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("supports" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *DomainActorDocument) contextValidateThumbnail(ctx context.Context, formats strfmt.Registry) error {

	if m.Thumbnail != nil {

		if swag.IsZero(m.Thumbnail) { // not required
			return nil
		}

		if err := m.Thumbnail.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("thumbnail")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("thumbnail")
			}
			return err
		}
	}

	return nil
}

func (m *DomainActorDocument) contextValidateUsesThreats(ctx context.Context, formats strfmt.Registry) error {

	for i := 0; i < len(m.UsesThreats); i++ {

		if m.UsesThreats[i] != nil {

			if swag.IsZero(m.UsesThreats[i]) { // not required
				return nil
			}

			if err := m.UsesThreats[i].ContextValidate(ctx, formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("uses_threats" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("uses_threats" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

// MarshalBinary interface implementation
func (m *DomainActorDocument) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *DomainActorDocument) UnmarshalBinary(b []byte) error {
	var res DomainActorDocument
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}
