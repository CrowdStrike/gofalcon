// Code generated by go-swagger; DO NOT EDIT.

package models

// This file was generated by the swagger tool.
// Editing this file might prove futile when you re-run the swagger generate command

import (
	"context"
	"strconv"

	"github.com/go-openapi/errors"
	"github.com/go-openapi/strfmt"
	"github.com/go-openapi/swag"
	"github.com/go-openapi/validate"
)

// DomainDiscoverAPIApplication Represents information about an application.
//
// swagger:model domain.DiscoverAPIApplication
type DomainDiscoverAPIApplication struct {

	// Represents the application architectures (x86 / x64).
	Architectures []string `json:"architectures"`

	// Details about the browser extension. Populated for applications of a browser extension type
	BrowserExtension *DomainDiscoverAPIApplicationBrowserExtension `json:"browser_extension,omitempty"`

	// The category of the application.
	Category string `json:"category,omitempty"`

	// The customer ID of this application.
	// Required: true
	Cid *string `json:"cid"`

	// Details about the package. Populated for applications of a package type
	DevPackage *DomainDiscoverAPIApplicationPackage `json:"dev_package,omitempty"`

	// The unique identifier for the extension.
	ExtensionID string `json:"extension_id,omitempty"`

	// Timestamp when this application was first seen by the cloud.
	FirstSeenTimestamp string `json:"first_seen_timestamp,omitempty"`

	// The user defined groups this application is part of.
	Groups []string `json:"groups"`

	// The homepage URL of the application.
	Homepage string `json:"homepage,omitempty"`

	// The host on which an application is installed and/or used.
	Host *DomainDiscoverAPIApplicationHost `json:"host,omitempty"`

	// The unique ID for the application.
	// Required: true
	ID *string `json:"id"`

	// Details about the extension. Populated for applications of an ide_extension type
	IdeExtension *DomainDiscoverAPIApplicationIDEExtension `json:"ide_extension,omitempty"`

	// The file paths where the application is installed on the host. Or the locations of the executables.
	InstallationPaths []string `json:"installation_paths"`

	// Timestamp when the application was installed on the host. We might not have this data.
	InstallationTimestamp string `json:"installation_timestamp,omitempty"`

	// Whether or not the application is normalized
	IsNormalized bool `json:"is_normalized,omitempty"`

	// Whether or not the application is suspicious (detection-based for malware)
	IsSuspicious bool `json:"is_suspicious,omitempty"`

	// Timestamp when this application was last published.
	LastPublished string `json:"last_published,omitempty"`

	// Timestamp when this application was last updated (something changed in the application or in the host data).
	LastUpdatedTimestamp string `json:"last_updated_timestamp,omitempty"`

	// The file hash that was last used for this application.
	LastUsedFileHash string `json:"last_used_file_hash,omitempty"`

	// The file name that was last used for this application.
	LastUsedFileName string `json:"last_used_file_name,omitempty"`

	// Timestamp when this application was last used.
	LastUsedTimestamp string `json:"last_used_timestamp,omitempty"`

	// The username of the user that last used this application.
	LastUsedUserName string `json:"last_used_user_name,omitempty"`

	// The user SID of the last user that used this application.
	LastUsedUserSid string `json:"last_used_user_sid,omitempty"`

	// The name of the application.
	Name string `json:"name,omitempty"`

	// The combined field on which we will be able to group by app.
	NameVendor string `json:"name_vendor,omitempty"`

	// The combined field on which we will be able to group by app + version.
	NameVendorVersion string `json:"name_vendor_version,omitempty"`

	// The type of software of the application. Types are application, browser_extension, dev_package, ide_extension
	SoftwareType string `json:"software_type,omitempty"`

	// The store listing information for the application.
	StoreListing string `json:"store_listing,omitempty"`

	// The status of the application in the store listing.
	StoreListingStatus string `json:"store_listing_status,omitempty"`

	// List of security risk indicators for this application
	SuspiciousIndicators []*DomainDiscoverAPISuspiciousIndicator `json:"suspicious_indicators"`

	// The name the application's vendor.
	Vendor string `json:"vendor,omitempty"`

	// The version of the application.
	Version string `json:"version,omitempty"`

	// The version scheme of the application.
	VersioningScheme string `json:"versioning_scheme,omitempty"`
}

// Validate validates this domain discover API application
func (m *DomainDiscoverAPIApplication) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateBrowserExtension(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateCid(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateDevPackage(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateHost(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateID(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateIdeExtension(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateSuspiciousIndicators(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *DomainDiscoverAPIApplication) validateBrowserExtension(formats strfmt.Registry) error {
	if swag.IsZero(m.BrowserExtension) { // not required
		return nil
	}

	if m.BrowserExtension != nil {
		if err := m.BrowserExtension.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("browser_extension")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("browser_extension")
			}
			return err
		}
	}

	return nil
}

func (m *DomainDiscoverAPIApplication) validateCid(formats strfmt.Registry) error {

	if err := validate.Required("cid", "body", m.Cid); err != nil {
		return err
	}

	return nil
}

func (m *DomainDiscoverAPIApplication) validateDevPackage(formats strfmt.Registry) error {
	if swag.IsZero(m.DevPackage) { // not required
		return nil
	}

	if m.DevPackage != nil {
		if err := m.DevPackage.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("dev_package")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("dev_package")
			}
			return err
		}
	}

	return nil
}

func (m *DomainDiscoverAPIApplication) validateHost(formats strfmt.Registry) error {
	if swag.IsZero(m.Host) { // not required
		return nil
	}

	if m.Host != nil {
		if err := m.Host.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("host")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("host")
			}
			return err
		}
	}

	return nil
}

func (m *DomainDiscoverAPIApplication) validateID(formats strfmt.Registry) error {

	if err := validate.Required("id", "body", m.ID); err != nil {
		return err
	}

	return nil
}

func (m *DomainDiscoverAPIApplication) validateIdeExtension(formats strfmt.Registry) error {
	if swag.IsZero(m.IdeExtension) { // not required
		return nil
	}

	if m.IdeExtension != nil {
		if err := m.IdeExtension.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("ide_extension")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("ide_extension")
			}
			return err
		}
	}

	return nil
}

func (m *DomainDiscoverAPIApplication) validateSuspiciousIndicators(formats strfmt.Registry) error {
	if swag.IsZero(m.SuspiciousIndicators) { // not required
		return nil
	}

	for i := 0; i < len(m.SuspiciousIndicators); i++ {
		if swag.IsZero(m.SuspiciousIndicators[i]) { // not required
			continue
		}

		if m.SuspiciousIndicators[i] != nil {
			if err := m.SuspiciousIndicators[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("suspicious_indicators" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("suspicious_indicators" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

// ContextValidate validate this domain discover API application based on the context it is used
func (m *DomainDiscoverAPIApplication) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateBrowserExtension(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateDevPackage(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateHost(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateIdeExtension(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateSuspiciousIndicators(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *DomainDiscoverAPIApplication) contextValidateBrowserExtension(ctx context.Context, formats strfmt.Registry) error {

	if m.BrowserExtension != nil {

		if swag.IsZero(m.BrowserExtension) { // not required
			return nil
		}

		if err := m.BrowserExtension.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("browser_extension")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("browser_extension")
			}
			return err
		}
	}

	return nil
}

func (m *DomainDiscoverAPIApplication) contextValidateDevPackage(ctx context.Context, formats strfmt.Registry) error {

	if m.DevPackage != nil {

		if swag.IsZero(m.DevPackage) { // not required
			return nil
		}

		if err := m.DevPackage.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("dev_package")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("dev_package")
			}
			return err
		}
	}

	return nil
}

func (m *DomainDiscoverAPIApplication) contextValidateHost(ctx context.Context, formats strfmt.Registry) error {

	if m.Host != nil {

		if swag.IsZero(m.Host) { // not required
			return nil
		}

		if err := m.Host.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("host")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("host")
			}
			return err
		}
	}

	return nil
}

func (m *DomainDiscoverAPIApplication) contextValidateIdeExtension(ctx context.Context, formats strfmt.Registry) error {

	if m.IdeExtension != nil {

		if swag.IsZero(m.IdeExtension) { // not required
			return nil
		}

		if err := m.IdeExtension.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("ide_extension")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("ide_extension")
			}
			return err
		}
	}

	return nil
}

func (m *DomainDiscoverAPIApplication) contextValidateSuspiciousIndicators(ctx context.Context, formats strfmt.Registry) error {

	for i := 0; i < len(m.SuspiciousIndicators); i++ {

		if m.SuspiciousIndicators[i] != nil {

			if swag.IsZero(m.SuspiciousIndicators[i]) { // not required
				return nil
			}

			if err := m.SuspiciousIndicators[i].ContextValidate(ctx, formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("suspicious_indicators" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("suspicious_indicators" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

// MarshalBinary interface implementation
func (m *DomainDiscoverAPIApplication) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *DomainDiscoverAPIApplication) UnmarshalBinary(b []byte) error {
	var res DomainDiscoverAPIApplication
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}
