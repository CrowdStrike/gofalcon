// Code generated by go-swagger; DO NOT EDIT.

package models

// This file was generated by the swagger tool.
// Editing this file might prove futile when you re-run the swagger generate command

import (
	"context"
	"strconv"

	"github.com/go-openapi/errors"
	"github.com/go-openapi/strfmt"
	"github.com/go-openapi/swag"
	"github.com/go-openapi/validate"
)

// DomainMalwareDocument JSON definition of a Malware, also known as a Threat
//
// swagger:model domain.MalwareDocument
type DomainMalwareDocument struct {

	// actors count
	ActorsCount int64 `json:"actors_count,omitempty"`

	// All the Systems affected (i.e AWS, Lambda)
	AllSystems []string `json:"all_systems"`

	// All the actors related to this Malware
	AssociatedActors []*DomainDenormalizedAdversaryReference `json:"associated_actors"`

	// capabilities
	Capabilities []string `json:"capabilities"`

	// Malware's community identifiers
	CommunityIdentifiers []string `json:"community_identifiers"`

	// Malware's creation date when it was added to CKB in unix timestamp format
	CreatedTimestamp string `json:"created_timestamp,omitempty"`

	// Malware's text description
	Description string `json:"description,omitempty"`

	// description text length
	DescriptionTextLength int64 `json:"description_text_length,omitempty"`

	// Actors that developed this Malware
	DevelopedBy []*DomainDenormalizedAdversaryReference `json:"developed_by"`

	// developed by count
	DevelopedByCount int64 `json:"developed_by_count,omitempty"`

	// files containing threat count
	FilesContainingThreatCount int64 `json:"files_containing_threat_count,omitempty"`

	// Alphanumeric ID for the Malware
	// Required: true
	ID *string `json:"id"`

	// indicator count
	IndicatorCount int64 `json:"indicator_count,omitempty"`

	// kill chain
	KillChain []string `json:"kill_chain"`

	// Malware's last updated date in unix timestamp format
	LastUpdated string `json:"last_updated,omitempty"`

	// MITRE used by this Malware
	Mitre []*DomainDenormalizedThreatUsedMitre `json:"mitre"`

	// mitre attack count
	MitreAttackCount int64 `json:"mitre_attack_count,omitempty"`

	// mitre tactic count
	MitreTacticCount int64 `json:"mitre_tactic_count,omitempty"`

	// mitre technique count
	MitreTechniqueCount int64 `json:"mitre_technique_count,omitempty"`

	// Malware's activity motivation, one of: State-Sponsored, Criminal, Hacktivism
	Motivation []string `json:"motivation"`

	// Malware's family name
	// Required: true
	Name *string `json:"name"`

	// The previous stage of this Malware
	NextStageOf []*DomainDenormalizedThreatReference `json:"next_stage_of"`

	// The next stages of this Malware
	NextStages []*DomainDenormalizedThreatReference `json:"next_stages"`

	// The parent of this Malware
	PluginOf []*DomainDenormalizedThreatReference `json:"plugin_of"`

	// The plugins of this Malware
	Plugins []*DomainDenormalizedThreatReference `json:"plugins"`

	// Actors that purchase this Malware
	PurchasedBy []*DomainDenormalizedAdversaryReference `json:"purchased_by"`

	// purchased by count
	PurchasedByCount int64 `json:"purchased_by_count,omitempty"`

	// report count
	ReportCount int64 `json:"report_count,omitempty"`

	// Reports that contain this Malware
	Reports []*DomainDenormalizedReportReference `json:"reports"`

	// Counts of detections, sandbox and vulnerabilities in costumer environment
	SeenInEnvironment *DomainMalwareEnvironmentAggregates `json:"seen_in_environment,omitempty"`

	// Name in url friendly format, lowercased and spaces replaced with dash
	Slug string `json:"slug,omitempty"`

	// Actors that sell this Malware
	SoldBy []*DomainDenormalizedAdversaryReference `json:"sold_by"`

	// sold by count
	SoldByCount int64 `json:"sold_by_count,omitempty"`

	// status
	Status string `json:"status,omitempty"`

	// The parent botnet of this Malware
	SubBotnetOf []*DomainDenormalizedThreatReference `json:"sub_botnet_of"`

	// The sub-botnets of this Malware
	SubBotnets []*DomainDenormalizedThreatReference `json:"sub_botnets"`

	// The predecessor of this Malware
	SuccessorOf []*DomainDenormalizedThreatReference `json:"successor_of"`

	// The successors of this Malware
	Successors []*DomainDenormalizedThreatReference `json:"successors"`

	// systems targeted count
	SystemsTargetedCount int64 `json:"systems_targeted_count,omitempty"`

	// Target countries of malware's activity and attacks, slug value is a 2 characters code for the country value, some examples: United States,United Kingdom,Germany,India,Japan,France,Australia,Canada,China
	TargetCountries []*DomainDenormalizedCountry `json:"target_countries"`

	// Target economical industries of malware's activity and attacks. List of available values: Government, Financial Services, Technology, Telecommunications, Healthcare, Energy, Academic, Media, Aerospace, NGO, Manufacturing, Industrials and Engineering, Retail, Hospitality, Consulting and Professional Services, Opportunistic, Aviation, Defense, Transportation, Oil and Gas, Legal, Pharmaceutical, Logistics, Military, Automotive, Food and Beverage, Consumer Goods, Real Estate, Insurance, Agriculture, Chemicals, Utilities, Maritime, Extractive, Travel, Dissident, Cryptocurrency, Entertainment, National Government, Law Enforcement, Think Tanks, Local Government, Sports Organizations, Computer Gaming, Biomedical, Nonprofit, Financial Management & Hedge Funds, Political Parties, Architectural and Engineering, Emergency Services, Social Media, International Government, Nuclear, Research Entities, Vocational and Higher-Level Education, eCommerce
	TargetIndustries []*DomainDenormalizedSector `json:"target_industries"`

	// Malware's targeting profile
	TargetingProfile []string `json:"targeting_profile"`

	// The System directly targeted by this Malware (i.e Lambda)
	TargetsSystems []*DomainDenormalizedCustomerTarget `json:"targets_systems"`

	// threat file count
	ThreatFileCount int64 `json:"threat_file_count,omitempty"`

	// Malware's properties one of: Commodity, OpenSource, SourceCodeLeaked, Modular, RepurposedLegitimateSoftware
	ThreatProperties []string `json:"threat_properties"`

	// threat relations count
	ThreatRelationsCount int64 `json:"threat_relations_count,omitempty"`

	// Actors that use this Malware
	UsedBy []*DomainDenormalizedAdversaryReference `json:"used_by"`

	// used by count
	UsedByCount int64 `json:"used_by_count,omitempty"`

	// The parent variant of this Malware
	VariantOf []*DomainDenormalizedThreatReference `json:"variant_of"`

	// The variants of this Malware
	Variants []*DomainDenormalizedThreatReference `json:"variants"`

	// Vulnerabilities this Malware exploits
	Vulnerabilities []*DomainVuln `json:"vulnerabilities"`
}

// Validate validates this domain malware document
func (m *DomainMalwareDocument) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateAssociatedActors(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateDevelopedBy(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateID(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateMitre(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateName(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateNextStageOf(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateNextStages(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validatePluginOf(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validatePlugins(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validatePurchasedBy(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateReports(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateSeenInEnvironment(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateSoldBy(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateSubBotnetOf(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateSubBotnets(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateSuccessorOf(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateSuccessors(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateTargetCountries(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateTargetIndustries(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateTargetsSystems(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateUsedBy(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateVariantOf(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateVariants(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateVulnerabilities(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *DomainMalwareDocument) validateAssociatedActors(formats strfmt.Registry) error {
	if swag.IsZero(m.AssociatedActors) { // not required
		return nil
	}

	for i := 0; i < len(m.AssociatedActors); i++ {
		if swag.IsZero(m.AssociatedActors[i]) { // not required
			continue
		}

		if m.AssociatedActors[i] != nil {
			if err := m.AssociatedActors[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("associated_actors" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("associated_actors" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *DomainMalwareDocument) validateDevelopedBy(formats strfmt.Registry) error {
	if swag.IsZero(m.DevelopedBy) { // not required
		return nil
	}

	for i := 0; i < len(m.DevelopedBy); i++ {
		if swag.IsZero(m.DevelopedBy[i]) { // not required
			continue
		}

		if m.DevelopedBy[i] != nil {
			if err := m.DevelopedBy[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("developed_by" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("developed_by" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *DomainMalwareDocument) validateID(formats strfmt.Registry) error {

	if err := validate.Required("id", "body", m.ID); err != nil {
		return err
	}

	return nil
}

func (m *DomainMalwareDocument) validateMitre(formats strfmt.Registry) error {
	if swag.IsZero(m.Mitre) { // not required
		return nil
	}

	for i := 0; i < len(m.Mitre); i++ {
		if swag.IsZero(m.Mitre[i]) { // not required
			continue
		}

		if m.Mitre[i] != nil {
			if err := m.Mitre[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("mitre" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("mitre" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *DomainMalwareDocument) validateName(formats strfmt.Registry) error {

	if err := validate.Required("name", "body", m.Name); err != nil {
		return err
	}

	return nil
}

func (m *DomainMalwareDocument) validateNextStageOf(formats strfmt.Registry) error {
	if swag.IsZero(m.NextStageOf) { // not required
		return nil
	}

	for i := 0; i < len(m.NextStageOf); i++ {
		if swag.IsZero(m.NextStageOf[i]) { // not required
			continue
		}

		if m.NextStageOf[i] != nil {
			if err := m.NextStageOf[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("next_stage_of" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("next_stage_of" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *DomainMalwareDocument) validateNextStages(formats strfmt.Registry) error {
	if swag.IsZero(m.NextStages) { // not required
		return nil
	}

	for i := 0; i < len(m.NextStages); i++ {
		if swag.IsZero(m.NextStages[i]) { // not required
			continue
		}

		if m.NextStages[i] != nil {
			if err := m.NextStages[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("next_stages" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("next_stages" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *DomainMalwareDocument) validatePluginOf(formats strfmt.Registry) error {
	if swag.IsZero(m.PluginOf) { // not required
		return nil
	}

	for i := 0; i < len(m.PluginOf); i++ {
		if swag.IsZero(m.PluginOf[i]) { // not required
			continue
		}

		if m.PluginOf[i] != nil {
			if err := m.PluginOf[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("plugin_of" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("plugin_of" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *DomainMalwareDocument) validatePlugins(formats strfmt.Registry) error {
	if swag.IsZero(m.Plugins) { // not required
		return nil
	}

	for i := 0; i < len(m.Plugins); i++ {
		if swag.IsZero(m.Plugins[i]) { // not required
			continue
		}

		if m.Plugins[i] != nil {
			if err := m.Plugins[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("plugins" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("plugins" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *DomainMalwareDocument) validatePurchasedBy(formats strfmt.Registry) error {
	if swag.IsZero(m.PurchasedBy) { // not required
		return nil
	}

	for i := 0; i < len(m.PurchasedBy); i++ {
		if swag.IsZero(m.PurchasedBy[i]) { // not required
			continue
		}

		if m.PurchasedBy[i] != nil {
			if err := m.PurchasedBy[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("purchased_by" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("purchased_by" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *DomainMalwareDocument) validateReports(formats strfmt.Registry) error {
	if swag.IsZero(m.Reports) { // not required
		return nil
	}

	for i := 0; i < len(m.Reports); i++ {
		if swag.IsZero(m.Reports[i]) { // not required
			continue
		}

		if m.Reports[i] != nil {
			if err := m.Reports[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("reports" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("reports" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *DomainMalwareDocument) validateSeenInEnvironment(formats strfmt.Registry) error {
	if swag.IsZero(m.SeenInEnvironment) { // not required
		return nil
	}

	if m.SeenInEnvironment != nil {
		if err := m.SeenInEnvironment.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("seen_in_environment")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("seen_in_environment")
			}
			return err
		}
	}

	return nil
}

func (m *DomainMalwareDocument) validateSoldBy(formats strfmt.Registry) error {
	if swag.IsZero(m.SoldBy) { // not required
		return nil
	}

	for i := 0; i < len(m.SoldBy); i++ {
		if swag.IsZero(m.SoldBy[i]) { // not required
			continue
		}

		if m.SoldBy[i] != nil {
			if err := m.SoldBy[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("sold_by" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("sold_by" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *DomainMalwareDocument) validateSubBotnetOf(formats strfmt.Registry) error {
	if swag.IsZero(m.SubBotnetOf) { // not required
		return nil
	}

	for i := 0; i < len(m.SubBotnetOf); i++ {
		if swag.IsZero(m.SubBotnetOf[i]) { // not required
			continue
		}

		if m.SubBotnetOf[i] != nil {
			if err := m.SubBotnetOf[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("sub_botnet_of" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("sub_botnet_of" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *DomainMalwareDocument) validateSubBotnets(formats strfmt.Registry) error {
	if swag.IsZero(m.SubBotnets) { // not required
		return nil
	}

	for i := 0; i < len(m.SubBotnets); i++ {
		if swag.IsZero(m.SubBotnets[i]) { // not required
			continue
		}

		if m.SubBotnets[i] != nil {
			if err := m.SubBotnets[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("sub_botnets" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("sub_botnets" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *DomainMalwareDocument) validateSuccessorOf(formats strfmt.Registry) error {
	if swag.IsZero(m.SuccessorOf) { // not required
		return nil
	}

	for i := 0; i < len(m.SuccessorOf); i++ {
		if swag.IsZero(m.SuccessorOf[i]) { // not required
			continue
		}

		if m.SuccessorOf[i] != nil {
			if err := m.SuccessorOf[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("successor_of" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("successor_of" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *DomainMalwareDocument) validateSuccessors(formats strfmt.Registry) error {
	if swag.IsZero(m.Successors) { // not required
		return nil
	}

	for i := 0; i < len(m.Successors); i++ {
		if swag.IsZero(m.Successors[i]) { // not required
			continue
		}

		if m.Successors[i] != nil {
			if err := m.Successors[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("successors" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("successors" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *DomainMalwareDocument) validateTargetCountries(formats strfmt.Registry) error {
	if swag.IsZero(m.TargetCountries) { // not required
		return nil
	}

	for i := 0; i < len(m.TargetCountries); i++ {
		if swag.IsZero(m.TargetCountries[i]) { // not required
			continue
		}

		if m.TargetCountries[i] != nil {
			if err := m.TargetCountries[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("target_countries" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("target_countries" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *DomainMalwareDocument) validateTargetIndustries(formats strfmt.Registry) error {
	if swag.IsZero(m.TargetIndustries) { // not required
		return nil
	}

	for i := 0; i < len(m.TargetIndustries); i++ {
		if swag.IsZero(m.TargetIndustries[i]) { // not required
			continue
		}

		if m.TargetIndustries[i] != nil {
			if err := m.TargetIndustries[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("target_industries" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("target_industries" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *DomainMalwareDocument) validateTargetsSystems(formats strfmt.Registry) error {
	if swag.IsZero(m.TargetsSystems) { // not required
		return nil
	}

	for i := 0; i < len(m.TargetsSystems); i++ {
		if swag.IsZero(m.TargetsSystems[i]) { // not required
			continue
		}

		if m.TargetsSystems[i] != nil {
			if err := m.TargetsSystems[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("targets_systems" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("targets_systems" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *DomainMalwareDocument) validateUsedBy(formats strfmt.Registry) error {
	if swag.IsZero(m.UsedBy) { // not required
		return nil
	}

	for i := 0; i < len(m.UsedBy); i++ {
		if swag.IsZero(m.UsedBy[i]) { // not required
			continue
		}

		if m.UsedBy[i] != nil {
			if err := m.UsedBy[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("used_by" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("used_by" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *DomainMalwareDocument) validateVariantOf(formats strfmt.Registry) error {
	if swag.IsZero(m.VariantOf) { // not required
		return nil
	}

	for i := 0; i < len(m.VariantOf); i++ {
		if swag.IsZero(m.VariantOf[i]) { // not required
			continue
		}

		if m.VariantOf[i] != nil {
			if err := m.VariantOf[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("variant_of" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("variant_of" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *DomainMalwareDocument) validateVariants(formats strfmt.Registry) error {
	if swag.IsZero(m.Variants) { // not required
		return nil
	}

	for i := 0; i < len(m.Variants); i++ {
		if swag.IsZero(m.Variants[i]) { // not required
			continue
		}

		if m.Variants[i] != nil {
			if err := m.Variants[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("variants" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("variants" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *DomainMalwareDocument) validateVulnerabilities(formats strfmt.Registry) error {
	if swag.IsZero(m.Vulnerabilities) { // not required
		return nil
	}

	for i := 0; i < len(m.Vulnerabilities); i++ {
		if swag.IsZero(m.Vulnerabilities[i]) { // not required
			continue
		}

		if m.Vulnerabilities[i] != nil {
			if err := m.Vulnerabilities[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("vulnerabilities" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("vulnerabilities" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

// ContextValidate validate this domain malware document based on the context it is used
func (m *DomainMalwareDocument) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateAssociatedActors(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateDevelopedBy(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateMitre(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateNextStageOf(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateNextStages(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidatePluginOf(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidatePlugins(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidatePurchasedBy(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateReports(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateSeenInEnvironment(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateSoldBy(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateSubBotnetOf(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateSubBotnets(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateSuccessorOf(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateSuccessors(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateTargetCountries(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateTargetIndustries(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateTargetsSystems(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateUsedBy(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateVariantOf(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateVariants(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateVulnerabilities(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *DomainMalwareDocument) contextValidateAssociatedActors(ctx context.Context, formats strfmt.Registry) error {

	for i := 0; i < len(m.AssociatedActors); i++ {

		if m.AssociatedActors[i] != nil {

			if swag.IsZero(m.AssociatedActors[i]) { // not required
				return nil
			}

			if err := m.AssociatedActors[i].ContextValidate(ctx, formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("associated_actors" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("associated_actors" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *DomainMalwareDocument) contextValidateDevelopedBy(ctx context.Context, formats strfmt.Registry) error {

	for i := 0; i < len(m.DevelopedBy); i++ {

		if m.DevelopedBy[i] != nil {

			if swag.IsZero(m.DevelopedBy[i]) { // not required
				return nil
			}

			if err := m.DevelopedBy[i].ContextValidate(ctx, formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("developed_by" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("developed_by" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *DomainMalwareDocument) contextValidateMitre(ctx context.Context, formats strfmt.Registry) error {

	for i := 0; i < len(m.Mitre); i++ {

		if m.Mitre[i] != nil {

			if swag.IsZero(m.Mitre[i]) { // not required
				return nil
			}

			if err := m.Mitre[i].ContextValidate(ctx, formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("mitre" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("mitre" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *DomainMalwareDocument) contextValidateNextStageOf(ctx context.Context, formats strfmt.Registry) error {

	for i := 0; i < len(m.NextStageOf); i++ {

		if m.NextStageOf[i] != nil {

			if swag.IsZero(m.NextStageOf[i]) { // not required
				return nil
			}

			if err := m.NextStageOf[i].ContextValidate(ctx, formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("next_stage_of" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("next_stage_of" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *DomainMalwareDocument) contextValidateNextStages(ctx context.Context, formats strfmt.Registry) error {

	for i := 0; i < len(m.NextStages); i++ {

		if m.NextStages[i] != nil {

			if swag.IsZero(m.NextStages[i]) { // not required
				return nil
			}

			if err := m.NextStages[i].ContextValidate(ctx, formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("next_stages" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("next_stages" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *DomainMalwareDocument) contextValidatePluginOf(ctx context.Context, formats strfmt.Registry) error {

	for i := 0; i < len(m.PluginOf); i++ {

		if m.PluginOf[i] != nil {

			if swag.IsZero(m.PluginOf[i]) { // not required
				return nil
			}

			if err := m.PluginOf[i].ContextValidate(ctx, formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("plugin_of" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("plugin_of" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *DomainMalwareDocument) contextValidatePlugins(ctx context.Context, formats strfmt.Registry) error {

	for i := 0; i < len(m.Plugins); i++ {

		if m.Plugins[i] != nil {

			if swag.IsZero(m.Plugins[i]) { // not required
				return nil
			}

			if err := m.Plugins[i].ContextValidate(ctx, formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("plugins" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("plugins" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *DomainMalwareDocument) contextValidatePurchasedBy(ctx context.Context, formats strfmt.Registry) error {

	for i := 0; i < len(m.PurchasedBy); i++ {

		if m.PurchasedBy[i] != nil {

			if swag.IsZero(m.PurchasedBy[i]) { // not required
				return nil
			}

			if err := m.PurchasedBy[i].ContextValidate(ctx, formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("purchased_by" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("purchased_by" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *DomainMalwareDocument) contextValidateReports(ctx context.Context, formats strfmt.Registry) error {

	for i := 0; i < len(m.Reports); i++ {

		if m.Reports[i] != nil {

			if swag.IsZero(m.Reports[i]) { // not required
				return nil
			}

			if err := m.Reports[i].ContextValidate(ctx, formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("reports" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("reports" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *DomainMalwareDocument) contextValidateSeenInEnvironment(ctx context.Context, formats strfmt.Registry) error {

	if m.SeenInEnvironment != nil {

		if swag.IsZero(m.SeenInEnvironment) { // not required
			return nil
		}

		if err := m.SeenInEnvironment.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("seen_in_environment")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("seen_in_environment")
			}
			return err
		}
	}

	return nil
}

func (m *DomainMalwareDocument) contextValidateSoldBy(ctx context.Context, formats strfmt.Registry) error {

	for i := 0; i < len(m.SoldBy); i++ {

		if m.SoldBy[i] != nil {

			if swag.IsZero(m.SoldBy[i]) { // not required
				return nil
			}

			if err := m.SoldBy[i].ContextValidate(ctx, formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("sold_by" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("sold_by" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *DomainMalwareDocument) contextValidateSubBotnetOf(ctx context.Context, formats strfmt.Registry) error {

	for i := 0; i < len(m.SubBotnetOf); i++ {

		if m.SubBotnetOf[i] != nil {

			if swag.IsZero(m.SubBotnetOf[i]) { // not required
				return nil
			}

			if err := m.SubBotnetOf[i].ContextValidate(ctx, formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("sub_botnet_of" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("sub_botnet_of" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *DomainMalwareDocument) contextValidateSubBotnets(ctx context.Context, formats strfmt.Registry) error {

	for i := 0; i < len(m.SubBotnets); i++ {

		if m.SubBotnets[i] != nil {

			if swag.IsZero(m.SubBotnets[i]) { // not required
				return nil
			}

			if err := m.SubBotnets[i].ContextValidate(ctx, formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("sub_botnets" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("sub_botnets" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *DomainMalwareDocument) contextValidateSuccessorOf(ctx context.Context, formats strfmt.Registry) error {

	for i := 0; i < len(m.SuccessorOf); i++ {

		if m.SuccessorOf[i] != nil {

			if swag.IsZero(m.SuccessorOf[i]) { // not required
				return nil
			}

			if err := m.SuccessorOf[i].ContextValidate(ctx, formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("successor_of" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("successor_of" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *DomainMalwareDocument) contextValidateSuccessors(ctx context.Context, formats strfmt.Registry) error {

	for i := 0; i < len(m.Successors); i++ {

		if m.Successors[i] != nil {

			if swag.IsZero(m.Successors[i]) { // not required
				return nil
			}

			if err := m.Successors[i].ContextValidate(ctx, formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("successors" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("successors" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *DomainMalwareDocument) contextValidateTargetCountries(ctx context.Context, formats strfmt.Registry) error {

	for i := 0; i < len(m.TargetCountries); i++ {

		if m.TargetCountries[i] != nil {

			if swag.IsZero(m.TargetCountries[i]) { // not required
				return nil
			}

			if err := m.TargetCountries[i].ContextValidate(ctx, formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("target_countries" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("target_countries" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *DomainMalwareDocument) contextValidateTargetIndustries(ctx context.Context, formats strfmt.Registry) error {

	for i := 0; i < len(m.TargetIndustries); i++ {

		if m.TargetIndustries[i] != nil {

			if swag.IsZero(m.TargetIndustries[i]) { // not required
				return nil
			}

			if err := m.TargetIndustries[i].ContextValidate(ctx, formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("target_industries" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("target_industries" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *DomainMalwareDocument) contextValidateTargetsSystems(ctx context.Context, formats strfmt.Registry) error {

	for i := 0; i < len(m.TargetsSystems); i++ {

		if m.TargetsSystems[i] != nil {

			if swag.IsZero(m.TargetsSystems[i]) { // not required
				return nil
			}

			if err := m.TargetsSystems[i].ContextValidate(ctx, formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("targets_systems" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("targets_systems" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *DomainMalwareDocument) contextValidateUsedBy(ctx context.Context, formats strfmt.Registry) error {

	for i := 0; i < len(m.UsedBy); i++ {

		if m.UsedBy[i] != nil {

			if swag.IsZero(m.UsedBy[i]) { // not required
				return nil
			}

			if err := m.UsedBy[i].ContextValidate(ctx, formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("used_by" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("used_by" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *DomainMalwareDocument) contextValidateVariantOf(ctx context.Context, formats strfmt.Registry) error {

	for i := 0; i < len(m.VariantOf); i++ {

		if m.VariantOf[i] != nil {

			if swag.IsZero(m.VariantOf[i]) { // not required
				return nil
			}

			if err := m.VariantOf[i].ContextValidate(ctx, formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("variant_of" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("variant_of" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *DomainMalwareDocument) contextValidateVariants(ctx context.Context, formats strfmt.Registry) error {

	for i := 0; i < len(m.Variants); i++ {

		if m.Variants[i] != nil {

			if swag.IsZero(m.Variants[i]) { // not required
				return nil
			}

			if err := m.Variants[i].ContextValidate(ctx, formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("variants" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("variants" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *DomainMalwareDocument) contextValidateVulnerabilities(ctx context.Context, formats strfmt.Registry) error {

	for i := 0; i < len(m.Vulnerabilities); i++ {

		if m.Vulnerabilities[i] != nil {

			if swag.IsZero(m.Vulnerabilities[i]) { // not required
				return nil
			}

			if err := m.Vulnerabilities[i].ContextValidate(ctx, formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("vulnerabilities" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("vulnerabilities" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

// MarshalBinary interface implementation
func (m *DomainMalwareDocument) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *DomainMalwareDocument) UnmarshalBinary(b []byte) error {
	var res DomainMalwareDocument
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}
