// Code generated by go-swagger; DO NOT EDIT.

package models

// This file was generated by the swagger tool.
// Editing this file might prove futile when you re-run the swagger generate command

import (
	"context"

	"github.com/go-openapi/errors"
	"github.com/go-openapi/strfmt"
	"github.com/go-openapi/swag"
	"github.com/go-openapi/validate"
)

// DomainGPA domain g p a
//
// swagger:model domain.GPA
type DomainGPA struct {

	// algorithm header name
	AlgorithmHeaderName string `json:"algorithm_header_name,omitempty"`

	// encoding of the signature, defaults to base64
	Encoding string `json:"encoding,omitempty"`

	// delimiter used between fields
	FieldDelimiter string `json:"field_delimiter,omitempty"`

	// fields of the signature
	Fields []string `json:"fields"`

	// hash function to use; defaults to sha256
	HashFunction string `json:"hash_function,omitempty"`

	// header value for signature using ${} wrapped variables
	HeaderFormat string `json:"header_format,omitempty"`

	// name of the header the base64 encoded signature is matched; example: X-CS-Primary-SecretKey; default: Authorization
	HeaderName string `json:"header_name,omitempty"`

	// private key used to hash
	// Required: true
	Key *string `json:"key"`

	// the timestamp format; defaults to RFC3339
	TimestampFormat string `json:"timestamp_format,omitempty"`

	// timestamp header name
	TimestampHeaderName string `json:"timestamp_header_name,omitempty"`

	// Preset type of hmac config. This takes precedence over other config fields, so if this field is set, then it uses the native implementation to generate the hmac signature
	Type string `json:"type,omitempty"`
}

// Validate validates this domain g p a
func (m *DomainGPA) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateKey(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *DomainGPA) validateKey(formats strfmt.Registry) error {

	if err := validate.Required("key", "body", m.Key); err != nil {
		return err
	}

	return nil
}

// ContextValidate validates this domain g p a based on context it is used
func (m *DomainGPA) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (m *DomainGPA) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *DomainGPA) UnmarshalBinary(b []byte) error {
	var res DomainGPA
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}
