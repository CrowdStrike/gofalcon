// Code generated by go-swagger; DO NOT EDIT.

package models

// This file was generated by the swagger tool.
// Editing this file might prove futile when you re-run the swagger generate command

import (
	"context"
	"strconv"

	"github.com/go-openapi/errors"
	"github.com/go-openapi/strfmt"
	"github.com/go-openapi/swag"
	"github.com/go-openapi/validate"
)

// AssetGetAssetInventory asset get asset inventory
//
// swagger:model Asset_GetAssetInventory
type AssetGetAssetInventory struct {

	// Access level
	// Min Length: 1
	AccessLevel string `json:"access_level,omitempty"`

	// Account id
	// Required: true
	AccountID *string `json:"account_id"`

	// Created
	// Required: true
	// Min Length: 1
	Created *string `json:"created"`

	// Drive
	// Min Length: 1
	Drive string `json:"drive,omitempty"`

	// Drive id
	// Min Length: 1
	DriveID string `json:"drive_id,omitempty"`

	// Integration alias
	// Required: true
	// Min Length: 1
	IntegrationAlias *string `json:"integration_alias"`

	// Integration id
	// Required: true
	// Min Length: 1
	IntegrationID *string `json:"integration_id"`

	// Integration name
	// Required: true
	// Min Length: 1
	IntegrationName *string `json:"integration_name"`

	// Last accessed
	// Required: true
	// Min Length: 1
	LastAccessed *string `json:"last_accessed"`

	// Last modified
	// Required: true
	// Min Length: 1
	LastModified *string `json:"last_modified"`

	// Parent
	// Min Length: 1
	Parent string `json:"parent,omitempty"`

	// Password protected
	PasswordProtected bool `json:"password_protected,omitempty"`

	// Permission id
	// Min Length: 1
	PermissionID string `json:"permission_id,omitempty"`

	// Resource id
	// Required: true
	// Min Length: 1
	ResourceID *string `json:"resource_id"`

	// Resource name
	// Required: true
	// Min Length: 1
	ResourceName *string `json:"resource_name"`

	// Resource owner
	// Required: true
	// Min Length: 1
	ResourceOwner *string `json:"resource_owner"`

	// Resource owner department
	// Required: true
	// Min Length: 1
	ResourceOwnerDepartment *string `json:"resource_owner_department"`

	// Resource owner enabled
	// Required: true
	ResourceOwnerEnabled *bool `json:"resource_owner_enabled"`

	// Resource type
	// Required: true
	// Min Length: 1
	ResourceType *string `json:"resource_type"`

	// shared with
	SharedWith []string `json:"shared_with"`
}

// Validate validates this asset get asset inventory
func (m *AssetGetAssetInventory) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateAccessLevel(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateAccountID(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateCreated(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateDrive(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateDriveID(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateIntegrationAlias(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateIntegrationID(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateIntegrationName(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateLastAccessed(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateLastModified(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateParent(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validatePermissionID(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateResourceID(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateResourceName(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateResourceOwner(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateResourceOwnerDepartment(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateResourceOwnerEnabled(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateResourceType(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateSharedWith(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *AssetGetAssetInventory) validateAccessLevel(formats strfmt.Registry) error {
	if swag.IsZero(m.AccessLevel) { // not required
		return nil
	}

	if err := validate.MinLength("access_level", "body", m.AccessLevel, 1); err != nil {
		return err
	}

	return nil
}

func (m *AssetGetAssetInventory) validateAccountID(formats strfmt.Registry) error {

	if err := validate.Required("account_id", "body", m.AccountID); err != nil {
		return err
	}

	return nil
}

func (m *AssetGetAssetInventory) validateCreated(formats strfmt.Registry) error {

	if err := validate.Required("created", "body", m.Created); err != nil {
		return err
	}

	if err := validate.MinLength("created", "body", *m.Created, 1); err != nil {
		return err
	}

	return nil
}

func (m *AssetGetAssetInventory) validateDrive(formats strfmt.Registry) error {
	if swag.IsZero(m.Drive) { // not required
		return nil
	}

	if err := validate.MinLength("drive", "body", m.Drive, 1); err != nil {
		return err
	}

	return nil
}

func (m *AssetGetAssetInventory) validateDriveID(formats strfmt.Registry) error {
	if swag.IsZero(m.DriveID) { // not required
		return nil
	}

	if err := validate.MinLength("drive_id", "body", m.DriveID, 1); err != nil {
		return err
	}

	return nil
}

func (m *AssetGetAssetInventory) validateIntegrationAlias(formats strfmt.Registry) error {

	if err := validate.Required("integration_alias", "body", m.IntegrationAlias); err != nil {
		return err
	}

	if err := validate.MinLength("integration_alias", "body", *m.IntegrationAlias, 1); err != nil {
		return err
	}

	return nil
}

func (m *AssetGetAssetInventory) validateIntegrationID(formats strfmt.Registry) error {

	if err := validate.Required("integration_id", "body", m.IntegrationID); err != nil {
		return err
	}

	if err := validate.MinLength("integration_id", "body", *m.IntegrationID, 1); err != nil {
		return err
	}

	return nil
}

func (m *AssetGetAssetInventory) validateIntegrationName(formats strfmt.Registry) error {

	if err := validate.Required("integration_name", "body", m.IntegrationName); err != nil {
		return err
	}

	if err := validate.MinLength("integration_name", "body", *m.IntegrationName, 1); err != nil {
		return err
	}

	return nil
}

func (m *AssetGetAssetInventory) validateLastAccessed(formats strfmt.Registry) error {

	if err := validate.Required("last_accessed", "body", m.LastAccessed); err != nil {
		return err
	}

	if err := validate.MinLength("last_accessed", "body", *m.LastAccessed, 1); err != nil {
		return err
	}

	return nil
}

func (m *AssetGetAssetInventory) validateLastModified(formats strfmt.Registry) error {

	if err := validate.Required("last_modified", "body", m.LastModified); err != nil {
		return err
	}

	if err := validate.MinLength("last_modified", "body", *m.LastModified, 1); err != nil {
		return err
	}

	return nil
}

func (m *AssetGetAssetInventory) validateParent(formats strfmt.Registry) error {
	if swag.IsZero(m.Parent) { // not required
		return nil
	}

	if err := validate.MinLength("parent", "body", m.Parent, 1); err != nil {
		return err
	}

	return nil
}

func (m *AssetGetAssetInventory) validatePermissionID(formats strfmt.Registry) error {
	if swag.IsZero(m.PermissionID) { // not required
		return nil
	}

	if err := validate.MinLength("permission_id", "body", m.PermissionID, 1); err != nil {
		return err
	}

	return nil
}

func (m *AssetGetAssetInventory) validateResourceID(formats strfmt.Registry) error {

	if err := validate.Required("resource_id", "body", m.ResourceID); err != nil {
		return err
	}

	if err := validate.MinLength("resource_id", "body", *m.ResourceID, 1); err != nil {
		return err
	}

	return nil
}

func (m *AssetGetAssetInventory) validateResourceName(formats strfmt.Registry) error {

	if err := validate.Required("resource_name", "body", m.ResourceName); err != nil {
		return err
	}

	if err := validate.MinLength("resource_name", "body", *m.ResourceName, 1); err != nil {
		return err
	}

	return nil
}

func (m *AssetGetAssetInventory) validateResourceOwner(formats strfmt.Registry) error {

	if err := validate.Required("resource_owner", "body", m.ResourceOwner); err != nil {
		return err
	}

	if err := validate.MinLength("resource_owner", "body", *m.ResourceOwner, 1); err != nil {
		return err
	}

	return nil
}

func (m *AssetGetAssetInventory) validateResourceOwnerDepartment(formats strfmt.Registry) error {

	if err := validate.Required("resource_owner_department", "body", m.ResourceOwnerDepartment); err != nil {
		return err
	}

	if err := validate.MinLength("resource_owner_department", "body", *m.ResourceOwnerDepartment, 1); err != nil {
		return err
	}

	return nil
}

func (m *AssetGetAssetInventory) validateResourceOwnerEnabled(formats strfmt.Registry) error {

	if err := validate.Required("resource_owner_enabled", "body", m.ResourceOwnerEnabled); err != nil {
		return err
	}

	return nil
}

func (m *AssetGetAssetInventory) validateResourceType(formats strfmt.Registry) error {

	if err := validate.Required("resource_type", "body", m.ResourceType); err != nil {
		return err
	}

	if err := validate.MinLength("resource_type", "body", *m.ResourceType, 1); err != nil {
		return err
	}

	return nil
}

func (m *AssetGetAssetInventory) validateSharedWith(formats strfmt.Registry) error {
	if swag.IsZero(m.SharedWith) { // not required
		return nil
	}

	for i := 0; i < len(m.SharedWith); i++ {

		if err := validate.MinLength("shared_with"+"."+strconv.Itoa(i), "body", m.SharedWith[i], 1); err != nil {
			return err
		}

	}

	return nil
}

// ContextValidate validates this asset get asset inventory based on context it is used
func (m *AssetGetAssetInventory) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (m *AssetGetAssetInventory) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *AssetGetAssetInventory) UnmarshalBinary(b []byte) error {
	var res AssetGetAssetInventory
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}
