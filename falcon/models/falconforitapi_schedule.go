// Code generated by go-swagger; DO NOT EDIT.

package models

// This file was generated by the swagger tool.
// Editing this file might prove futile when you re-run the swagger generate command

import (
	"context"
	"encoding/json"

	"github.com/go-openapi/errors"
	"github.com/go-openapi/strfmt"
	"github.com/go-openapi/swag"
	"github.com/go-openapi/validate"
)

// FalconforitapiSchedule falconforitapi schedule
//
// swagger:model falconforitapi.Schedule
type FalconforitapiSchedule struct {

	// Day of the month to run a Monthly schedule. Example: 5
	DayOfMonth int32 `json:"day_of_month,omitempty"`

	// Days of the week to run a Weekly schedule on. Example: ["Monday", "Tuesday"]
	DaysOfWeek []string `json:"days_of_week"`

	// Time that the schedule will stop running, in RFC3339 format. Example: 2026-05-14T22:17:00.000Z
	// Format: date-time
	EndTime strfmt.DateTime `json:"end_time,omitempty"`

	// Frequency of runs
	// Required: true
	// Enum: ["One-Time","Minutes","Hourly","Daily","Weekly","Monthly"]
	Frequency *string `json:"frequency"`

	// Minute interval for frequency:Minutes. Example: 30
	// Required: true
	Interval *int32 `json:"interval"`

	// Time that the schedule will first run, in RFC3339 format. Example: 2025-05-14T22:17:00.000Z
	// Format: date-time
	StartTime strfmt.DateTime `json:"start_time,omitempty"`

	// 24-hour time that a schedule should run at. Example: 17:17
	Time string `json:"time,omitempty"`

	// Timezone offset the time is set for. Example: -0500
	Timezone string `json:"timezone,omitempty"`
}

// Validate validates this falconforitapi schedule
func (m *FalconforitapiSchedule) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateEndTime(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateFrequency(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateInterval(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateStartTime(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *FalconforitapiSchedule) validateEndTime(formats strfmt.Registry) error {
	if swag.IsZero(m.EndTime) { // not required
		return nil
	}

	if err := validate.FormatOf("end_time", "body", "date-time", m.EndTime.String(), formats); err != nil {
		return err
	}

	return nil
}

var falconforitapiScheduleTypeFrequencyPropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["One-Time","Minutes","Hourly","Daily","Weekly","Monthly"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		falconforitapiScheduleTypeFrequencyPropEnum = append(falconforitapiScheduleTypeFrequencyPropEnum, v)
	}
}

const (

	// FalconforitapiScheduleFrequencyOneDashTime captures enum value "One-Time"
	FalconforitapiScheduleFrequencyOneDashTime string = "One-Time"

	// FalconforitapiScheduleFrequencyMinutes captures enum value "Minutes"
	FalconforitapiScheduleFrequencyMinutes string = "Minutes"

	// FalconforitapiScheduleFrequencyHourly captures enum value "Hourly"
	FalconforitapiScheduleFrequencyHourly string = "Hourly"

	// FalconforitapiScheduleFrequencyDaily captures enum value "Daily"
	FalconforitapiScheduleFrequencyDaily string = "Daily"

	// FalconforitapiScheduleFrequencyWeekly captures enum value "Weekly"
	FalconforitapiScheduleFrequencyWeekly string = "Weekly"

	// FalconforitapiScheduleFrequencyMonthly captures enum value "Monthly"
	FalconforitapiScheduleFrequencyMonthly string = "Monthly"
)

// prop value enum
func (m *FalconforitapiSchedule) validateFrequencyEnum(path, location string, value string) error {
	if err := validate.EnumCase(path, location, value, falconforitapiScheduleTypeFrequencyPropEnum, true); err != nil {
		return err
	}
	return nil
}

func (m *FalconforitapiSchedule) validateFrequency(formats strfmt.Registry) error {

	if err := validate.Required("frequency", "body", m.Frequency); err != nil {
		return err
	}

	// value enum
	if err := m.validateFrequencyEnum("frequency", "body", *m.Frequency); err != nil {
		return err
	}

	return nil
}

func (m *FalconforitapiSchedule) validateInterval(formats strfmt.Registry) error {

	if err := validate.Required("interval", "body", m.Interval); err != nil {
		return err
	}

	return nil
}

func (m *FalconforitapiSchedule) validateStartTime(formats strfmt.Registry) error {
	if swag.IsZero(m.StartTime) { // not required
		return nil
	}

	if err := validate.FormatOf("start_time", "body", "date-time", m.StartTime.String(), formats); err != nil {
		return err
	}

	return nil
}

// ContextValidate validates this falconforitapi schedule based on context it is used
func (m *FalconforitapiSchedule) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (m *FalconforitapiSchedule) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *FalconforitapiSchedule) UnmarshalBinary(b []byte) error {
	var res FalconforitapiSchedule
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}
